#!/usr/bin/python2.4
# usage:
#	adt-virt-chroot =[CHROOTNAME]
#		uses dchroot (but problems with spaces)
#		spaces in CHROOTNAME also not permitted
#	adt-virt-chroot [-rGAINROOT] /PATH/TO/CHROOT
#		uses GAINROOT chroot
#		GAINROOT will be split up if it has spaces

import sys
import os
import string
import urllib
import signal
import subprocess
import traceback
from optparse import OptionParser

debuglevel = None

class Quit:
	def __init__(q,ec,m): q.ec = ec; q.m = m

def bomb(m):
	raise Quit(12, "adt-virtual-chroot: failure: %s" % m)

def debug(m):
	if not debuglevel: return
	print >> sys.stderr, "adt-virt-chroot: debug:", m

def parse_args():
	global down, debuglevel

	usage = "%prog [options] =<dchroot>|/path/to/chroot"
	parser = OptionParser(usage=usage)
	pa = parser.add_option
	pe = parser.error

	pa('-r', '--gain-root', type='string', dest='gain_root');
	pa('-d', '--debug', action='store_true', dest='debug');

	(opts,args) = parser.parse_args()
	if len(args) != 1: pe("need exactly one arg, chroot specification")

	debuglevel = opts.debug

	chroot_arg = args[0]
	if not chroot_arg: pe("chroot specification may not be empty")
	if chroot_arg == '=': down = ['dchroot','-q']
	elif chroot_arg == '=': down = ['dchroot','-q']
	elif chroot_arg[0] == '=': down = ['dchroot','-q','-c',chroot_arg[1:]]
	elif chroot_arg[0] == '/': down = ['chroot',chroot_arg,'--']
	else: pe("chroot spec must be =[DCHROOT] or /PATH/TO/CHROOT")

	if opts.gain_root != None: down = opts.gain_root.split() + down

	debug("down = %s" % string.join(down))	

def ok(): print 'ok'

def cmdnumargs(c, ce, nargs=0):
	if len(c) == nargs + 1: return
	bomb("wrong number of arguments to command `%s'" % ce[0])

def cmd_capabilities(c, ce):
	cmdnumargs(c, ce)

def cmd_quit(c, ce):
	cmdnumargs(c, ce)
	raise Quit(0, '')

def execute_raw(what, *popenargs, **popenargsk):
	sp = subprocess.Popen(*popenargs, **popenargsk)
	(out, err) = sp.communicate()
	status = sp.wait()
	if status: bomb("%s%s failed (exit status %d)" %
			((downp and "(down) " or ""), what, status))
	if err: bomb("%s unexpectedly produced stderr output which we"
			"unexpectedly saw `%s'" % (what, err))
	return out

def execute(cmd_string, cmd_list=[], downp=False, outp=False):
	cmdl = cmd_string.split()

	if downp: perhaps_down = down
	else: downp = []

	if outp: stdout = subprocess.PIPE
	else: stdout = None

	cmd = perhaps_down + cmdl + cmd_list
	debug(" + %s" % string.join(cmd))

	out = execute_raw(cmdl[0], cmd, stdin=file('/dev/null','r'),
			stdout=stdout)
	if outp and out and out[-1]=='\n': out = out[:-1]
	return out

def cmd_open(c, ce):
	global downtmp
	cmdnumargs(c, ce)
	if downtmp: bomb("`open' when already open")
	execute('true', downp=True)
	downtmp = execute('mktemp -t -d', downp=True, outp=True)

def cmd_close(c, ce):
	global downtmp
	cmdnumargs(c, ce)
	if not downtmp: bomb("`close' when not open")
	cleanup()

def cmd_stop(c, ce):
	global downtmp
	cmdnumargs(c, ce, 1)
	if not downtmp: bomb("`stop' when not open")
	execute('rm -rf --', c[1:2])
	os.mkdir(c[1])
	cleanup()

def cmd_execute(c, ce):
	cmdnumargs(c, ce, 4)
	al = down
	for ion in range(3):
		pass

def command():
	ce = sys.stdin.readline()
	ce = ce.rstrip().split()
	c = map(urllib.unquote, ce)
	if not c: bomb('empty commands are not permitted')
	try: f = globals()['cmd_'+c[0]]
	except KeyError: bomb("unknown command `%s'" % cu[0])
	r = f(c, ce)
	if not r: r = []
	r.insert(0, 'ok')
	ru = map(urllib.quote, r)
	print string.join(ru)

def cleanup():
	global downtmp, cleaning
	cleaning = True
	if downtmp: execute('rm -rf --', [downtmp], downp=True)
	cleaning = False
	downtmp = False

def error_cleanup():
	try:
		ok = False
		try:
			cleanup()
			ok = True
		except Quit, q:
			print >> sys.stderr, q.m
		except:
			print >> sys.stderr, "Unexpected cleanup error:"
			traceback.print_exc()
			print >> sys.stderr, ''
		if not ok:
			print >> sys.stderr, ("while cleaning up"
				" because of another error:")
	except:
		pass

def prepare():
	global downtmp, cleaning
	downtmp = None
	signal_list = [	signal.SIGHUP, signal.SIGTERM,
			signal.SIGINT, signal.SIGPIPE ]
	def sethandlers(f):
		for signum in signal_list: signal.signal(signum, f)
	def handler(sig, *any):
		sethandlers(signal.SIG_DFL)
		cleanup()
		os.kill(os.getpid(), sig)
	sethandlers(handler)

parse_args()
ok()
prepare()

try:
	while True: command()
except Quit, q:
	error_cleanup()
	if q.m: print >> sys.stderr, q.m
	sys.exit(q.ec)
except:
	error_cleanup()
	print >> sys.stderr, "Unexpected error:"
	traceback.print_exc()
	sys.exit(16)
