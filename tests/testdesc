#!/usr/bin/python3

import os
import sys
import unittest
import tempfile
import shutil
import io

try:
    # Python >= 3.3
    from unittest.mock import patch
    patch  # pyflakes
except ImportError:
    # fall back to separate package
    from mock import patch

test_dir = os.path.dirname(os.path.abspath(__file__))
root_dir = os.path.dirname(test_dir)

if os.path.exists(os.path.join(root_dir, 'lib', 'testdesc.py')):
    our_base = os.path.join(root_dir, 'lib')
else:
    our_base = '/usr/share/autopkgtest/python'
sys.path.insert(1, our_base)

import adtlog
import testdesc


class Rfc822(unittest.TestCase):
    def test_control(self):
        '''Parse a debian/control like file'''

        control = tempfile.NamedTemporaryFile(prefix='control.')
        control.write('''Source: foo
Maintainer: Üñïcøδ€ <u@x.com>
Build-Depends: bd1, # moo
  bd2,
  bd3,
XS-Testsuite: autopkgtest
'''.encode())
        control.flush()
        parser = testdesc.parse_rfc822(control.name)
        r = parser.__next__()
        self.assertRaises(StopIteration, parser.__next__)
        control.close()

        self.assertEqual(r['Source'], 'foo')
        self.assertEqual(r['Xs-testsuite'], 'autopkgtest')
        self.assertEqual(r['Maintainer'], 'Üñïcøδ€ <u@x.com>')
        self.assertEqual(r['Build-depends'], 'bd1, bd2, bd3,')

    def test_dsc(self):
        '''Parse a signed dsc file'''

        control = tempfile.NamedTemporaryFile(prefix='dsc.')
        control.write('''-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: foo
Binary: foo-bin, foo-doc
Package-List:
 foo-bin deb utils optional arch=any
 foo-doc deb doc extra arch=all
Files:
 deadbeef 10000 foo_1.orig.tar.gz
 11111111 1000 foo_1-1.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

BloB11
-----END PGP SIGNATURE-----

'''.encode())
        control.flush()
        parser = testdesc.parse_rfc822(control.name)
        r = parser.__next__()
        self.assertRaises(StopIteration, parser.__next__)
        control.close()

        self.assertEqual(r['Format'], '3.0 (quilt)')
        self.assertEqual(r['Source'], 'foo')
        self.assertEqual(r['Binary'], 'foo-bin, foo-doc')
        self.assertEqual(r['Package-list'], ' foo-bin deb utils optional arch=any'
                         ' foo-doc deb doc extra arch=all')
        self.assertEqual(r['Files'], ' deadbeef 10000 foo_1.orig.tar.gz'
                         ' 11111111 1000 foo_1-1.debian.tar.xz')

    def test_invalid(self):
        '''Parse an invalid file'''

        control = tempfile.NamedTemporaryFile(prefix='bogus.')
        control.write('''Bo Gus: something
muhaha'''.encode())
        control.flush()
        parser = testdesc.parse_rfc822(control.name)
        self.assertRaises(StopIteration, parser.__next__)
        control.close()


class Test(unittest.TestCase):
    def test_valid_path(self):
        '''valid Test instantiation with path'''

        t = testdesc.Test('foo', 'tests/do_foo', None, ['needs-root'],
                          ['unknown_feature'], ['coreutils >= 7'], [])
        self.assertEqual(t.name, 'foo')
        self.assertEqual(t.path, 'tests/do_foo')
        self.assertEqual(t.command, None)
        self.assertEqual(t.result, None)

    def test_valid_command(self):
        '''valid Test instantiation with command'''

        t = testdesc.Test('foo', None, 'echo hi', ['needs-root'],
                          ['unknown_feature'], ['coreutils >= 7'], [])
        self.assertEqual(t.name, 'foo')
        self.assertEqual(t.path, None)
        self.assertEqual(t.command, 'echo hi')
        self.assertEqual(t.result, None)

    def test_invalid_name(self):
        '''Test with invalid name'''

        with self.assertRaises(testdesc.Unsupported) as cm:
            testdesc.Test('foo/bar', 'do_foo', None, [], [], [], [])
        self.assertIn('may not contain /', str(cm.exception))

    def test_unknown_restriction(self):
        '''Test with unknown restriction'''

        with self.assertRaises(testdesc.Unsupported) as cm:
            testdesc.Test('foo', 'tests/do_foo', None, ['needs-red'], [], [],
                          [])
        self.assertIn('unknown restriction needs-red', str(cm.exception))

    def test_neither_path_nor_command(self):
        '''Test without path nor command'''

        with self.assertRaises(testdesc.InvalidControl) as cm:
            testdesc.Test('foo', None, None, [], [], [], [])
        self.assertIn('either path or command', str(cm.exception))

    def test_both_path_and_command(self):
        '''Test with path and command'''

        with self.assertRaises(testdesc.InvalidControl) as cm:
            testdesc.Test('foo', 'do_foo', 'echo hi', [], [], [], [])
        self.assertIn('either path or command', str(cm.exception))

    def test_capabilities_compat(self):
        '''Test compatibility with testbed capabilities'''

        t = testdesc.Test('foo', 'tests/do_foo', None,
                          ['needs-root', 'isolation-container'], [], [], [])

        self.assertRaises(testdesc.Unsupported,
                          t.check_testbed_compat, ['isolation-container'])
        self.assertRaises(testdesc.Unsupported,
                          t.check_testbed_compat, ['root-on-testbed'])
        t.check_testbed_compat(['isolation-container', 'root-on-testbed'])


class Debian(unittest.TestCase):
    def setUp(self):
        self.pkgdir = tempfile.mkdtemp(prefix='testdesc.')
        os.makedirs(os.path.join(self.pkgdir, 'debian', 'tests'))
        self.addCleanup(shutil.rmtree, self.pkgdir)

    def call_parse(self, testcontrol, pkgcontrol=None, caps=[]):
        with open(os.path.join(self.pkgdir, 'debian', 'tests', 'control'), 'w', encoding='UTF-8') as f:
            f.write(testcontrol)
        if pkgcontrol:
            with open(os.path.join(self.pkgdir, 'debian', 'control'), 'w', encoding='UTF-8') as f:
                f.write(pkgcontrol)
        return testdesc.parse_debian_source(self.pkgdir, caps)

    def test_single(self):
        '''single test, simplest possible'''

        (ts, skipped) = self.call_parse('Tests: one\nDepends:')
        self.assertEqual(len(ts), 1)
        t = ts[0]
        self.assertEqual(t.name, 'one')
        self.assertEqual(t.path, 'debian/tests/one')
        self.assertEqual(t.restrictions, [])
        self.assertEqual(t.features, [])
        self.assertEqual(t.depends, [])
        self.assertFalse(skipped)

    def test_default_depends(self):
        '''default Depends: is @'''

        (ts, skipped) = self.call_parse(
            'Tests: t1 t2',
            'Source: nums\n\nPackage: one\nArchitecture: any\n\n'
            'Package: two\nArchitecture: all\n\n'
            'Package: two-udeb\nXC-Package-Type: udeb\nArchitecture: any')
        self.assertEqual(len(ts), 2)
        self.assertEqual(ts[0].name, 't1')
        self.assertEqual(ts[0].path, 'debian/tests/t1')
        self.assertEqual(ts[1].name, 't2')
        self.assertEqual(ts[1].path, 'debian/tests/t2')
        for t in ts:
            self.assertEqual(t.restrictions, [])
            self.assertEqual(t.features, [])
            self.assertEqual(t.depends, ['one', 'two'])
        self.assertFalse(skipped)

    def test_known_restrictions(self):
        '''known restrictions'''

        (ts, skipped) = self.call_parse(
            'Tests: t1 t2\nDepends: foo\nRestrictions: build-needed allow-stderr\nFeatures: blue\n\n'
            'Tests: three\nDepends:\nRestrictions: needs-recommends')
        self.assertEqual(len(ts), 3)

        self.assertEqual(ts[0].name, 't1')
        self.assertEqual(ts[0].restrictions, ['build-needed', 'allow-stderr'])
        self.assertEqual(ts[0].features, ['blue'])
        self.assertEqual(ts[0].depends, ['foo'])

        self.assertEqual(ts[1].name, 't2')
        self.assertEqual(ts[1].restrictions, ['build-needed', 'allow-stderr'])
        self.assertEqual(ts[1].features, ['blue'])
        self.assertEqual(ts[1].depends, ['foo'])

        self.assertEqual(ts[2].name, 'three')
        self.assertEqual(ts[2].path, 'debian/tests/three')
        self.assertEqual(ts[2].restrictions, ['needs-recommends'])
        self.assertEqual(ts[2].features, [])
        self.assertEqual(ts[2].depends, [])

        self.assertFalse(skipped)

    @patch('adtlog.report')
    def test_unknown_restriction(self, *args):
        '''unknown restriction'''

        (ts, skipped) = self.call_parse('Tests: t\nDepends:\nRestrictions: explodes-spontaneously')
        self.assertEqual(ts, [])
        self.assertTrue(skipped)
        adtlog.report.assert_called_once_with('t', 'SKIP unknown restriction explodes-spontaneously')

    def test_invalid_control(self):
        '''invalid control file'''

        # no tests field
        with self.assertRaises(testdesc.InvalidControl) as cm:
            self.call_parse('Depends:')
        self.assertIn('missing "Tests"', str(cm.exception))

    def test_tests_dir(self):
        '''non-standard Tests-Directory'''

        (ts, skipped) = self.call_parse(
            'Tests: t1\nDepends:\nTests-Directory: src/checks\n\n'
            'Tests: t2 t3\nDepends:\nTests-Directory: lib/t')

        self.assertEqual(len(ts), 3)
        self.assertEqual(ts[0].path, 'src/checks/t1')
        self.assertEqual(ts[1].path, 'lib/t/t2')
        self.assertEqual(ts[2].path, 'lib/t/t3')
        self.assertFalse(skipped)

    def test_builddeps(self):
        '''@builddeps@ expansion'''

        (ts, skipped) = self.call_parse(
            'Tests: t\nDepends: @, @builddeps@, foo (>= 7)',
            'Source: nums\nBuild-Depends: bd1, bd2 [armhf], bd3:native (>= 7) | bd4 [linux-any]\n'
            'Build-Depends-Indep: bdi1\n'
            '\n'
            'Package: one\nArchitecture: any')
        self.assertEqual(ts[0].depends, ['one', 'bd1', 'bd2 [armhf]',
                                         'bd3:native (>= 7) | bd4 [linux-any]',
                                         'bdi1', 'build-essential', 'foo (>= 7)'])
        self.assertFalse(skipped)

    def test_complex_deps(self):
        '''complex test dependencies'''

        (ts, skipped) = self.call_parse(
            'Tests: t\nDepends: @,\n foo (>= 7) [linux-any],\n'
            ' bd3:native (>= 4) | bd4 [armhf megacpu],\n',
            'Source: nums\n\nPackage: one\nArchitecture: any')
        self.assertEqual(ts[0].depends, ['one', 'foo (>= 7) [linux-any]',
                                         'bd3:native (>= 4) | bd4 [armhf megacpu]'])
        self.assertFalse(skipped)

    def test_invalid_test_deps(self):
        '''invalid test dependencies'''

        with self.assertRaises(testdesc.InvalidControl) as cm:
            self.call_parse('Tests: t\nDepends: blah foo:something')
        self.assertIn('Depends field contains an invalid dependency', str(cm.exception))
        self.assertIn('blah foo:something', str(cm.exception))

    def test_comments(self):
        '''comments in control files with Unicode'''

        (ts, skipped) = self.call_parse(
            'Tests: t\n# ♪ ï\nDepends: @, @builddeps@',
            'Source: nums\nMaintainer: Üñïcøδ€ <u@x.com>\nBuild-Depends: bd1 # moo\n'
            '# more c☺ mments\n'
            '\n'
            'Package: one\nArchitecture: any')
        self.assertEqual(ts[0].depends, ['one', 'bd1', 'build-essential'])
        self.assertFalse(skipped)

    @patch('adtlog.report')
    def test_testbed_compat(self, *args):
        '''restrictions incompatible with testbed'''

        (ts, skipped) = self.call_parse('Tests: t\nDepends:\nRestrictions: needs-root')
        self.assertEqual(ts, [])
        self.assertTrue(skipped)
        adtlog.report.assert_called_once_with(
            't', 'SKIP Test needs root on testbed which is not available')

    def test_custom_control_path(self):
        '''custom control file path'''

        os.makedirs(os.path.join(self.pkgdir, 'stuff'))
        c_path = os.path.join(self.pkgdir, 'stuff', 'adtctrl')
        with open(c_path, 'w') as f:
            f.write('Tests: one\nDepends: foo')

        (ts, skipped) = testdesc.parse_debian_source(self.pkgdir, [],
                                                     control_path=c_path)
        self.assertEqual(len(ts), 1)
        t = ts[0]
        self.assertEqual(t.name, 'one')
        self.assertEqual(t.path, 'debian/tests/one')
        self.assertEqual(t.restrictions, [])
        self.assertEqual(t.features, [])
        self.assertEqual(t.depends, ['foo'])
        self.assertFalse(skipped)


class Click(unittest.TestCase):
    def setUp(self):
        self.click = os.path.join(test_dir, 'testclick_0.1_all.click')
        self.click_src = os.path.join(test_dir, 'testclick')

    def test_all_fields(self):
        '''parsing manifest test with all possible fields'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "name": "foo",
  "x-test": {
    "t": {
      "path": "tests/do_t",
      "depends": ["foo (>= 1)", "bar | baz"],
      "restrictions": ["allow-stderr", "needs-recommends"],
      "features": ["turns-blue", "bites-back"]
    }
  }
}''', [], ['/foo/myapp.click'])
        self.assertEqual(len(ts), 1)
        self.assertEqual(ts[0].name, "t")
        self.assertEqual(ts[0].path, 'tests/do_t')
        self.assertEqual(ts[0].command, None)
        self.assertEqual(ts[0].depends, ['foo (>= 1)', 'bar | baz'])
        self.assertEqual(ts[0].clicks, ['/foo/myapp.click'])
        self.assertEqual(ts[0].restrictions, ['allow-stderr', 'needs-recommends'])
        self.assertEqual(ts[0].features, ['turns-blue', 'bites-back'])

        self.assertFalse(skipped)

    def test_no_tests(self):
        '''parsing manifest without tests'''

        self.assertEqual(
            testdesc.parse_click_manifest('{"name":"foo"}', [], []),
            ([], False))

    def test_path_only(self):
        '''test description is a single path'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "name": "foo",
  "x-test": {
      "t1": "tests/do_t",
      "t2": "runtests"
  }
}''', [], ['/foo/myapp.click'])
        self.assertEqual(len(ts), 2)
        self.assertEqual(ts[0].name, "t1")
        self.assertEqual(ts[0].path, 'tests/do_t')
        self.assertEqual(ts[1].name, "t2")
        self.assertEqual(ts[1].path, 'runtests')
        for i in [0, 1]:
            self.assertEqual(ts[i].command, None)
            self.assertEqual(ts[i].depends, [])
            self.assertEqual(ts[i].clicks, ['/foo/myapp.click'])
            self.assertEqual(ts[i].restrictions, [])
            self.assertEqual(ts[i].features, [])

        self.assertFalse(skipped)

    def test_autopilot_simple(self):
        '''simple autopilot test specification'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "name": "foo",
  "x-test": {
      "autopilot": "foo_tests"
  }
}''', [], ['/foo/myapp.click'])
        self.assertEqual(len(ts), 1)
        self.assertEqual(ts[0].name, "autopilot")
        self.assertEqual(ts[0].path, None)
        self.assertIn('PYTHONPATH=', ts[0].command)
        self.assertIn('autopilot', ts[0].command)
        self.assertIn('autopilot', ts[0].depends[0])
        self.assertEqual(ts[0].clicks, ['/foo/myapp.click'])
        self.assertEqual(ts[0].restrictions, [])
        self.assertEqual(ts[0].features, [])

        self.assertFalse(skipped)

    def test_autopilot_extradeps(self):
        '''autopilot test specification with extra info'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "name": "foo",
  "x-test": {
      "my_ap_test": {
          "autopilot_module": "foo_tests",
          "depends": ["extradep1"],
          "restrictions": ["allow-stderr"]
      }
  }
}''', [], ['/foo/myapp.click'])
        self.assertEqual(len(ts), 1)
        self.assertEqual(ts[0].name, 'my_ap_test')
        self.assertEqual(ts[0].path, None)
        self.assertIn('PYTHONPATH=', ts[0].command)
        self.assertIn('autopilot', ts[0].command)
        self.assertIn('autopilot', ts[0].depends[0])
        self.assertIn('extradep1', ts[0].depends)
        self.assertEqual(ts[0].clicks, ['/foo/myapp.click'])
        self.assertEqual(ts[0].restrictions, ['allow-stderr'])
        self.assertEqual(ts[0].features, [])

        self.assertFalse(skipped)

    def test_autopilot_manual_simple(self):
        '''simple manual autopilot test specification'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "name": "foo",
  "x-test": {
      "autopilot": "tests/run_tests"
  }
}''', [], ['/foo/myapp.click'])
        self.assertEqual(len(ts), 1)
        self.assertEqual(ts[0].name, "autopilot")
        self.assertEqual(ts[0].path, "tests/run_tests")
        self.assertEqual(ts[0].command, None)
        self.assertEqual(ts[0].clicks, ['/foo/myapp.click'])
        self.assertEqual(ts[0].depends, [])
        self.assertEqual(ts[0].restrictions, [])
        self.assertEqual(ts[0].features, [])

        self.assertFalse(skipped)

    def test_autopilot_manual_complex(self):
        '''complex manual autopilot test specification'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "name": "foo",
  "x-test": {
      "autopilot": {
          "path": "tests/run_tests"
      }
  }
}''', [], ['/foo/myapp.click'])
        self.assertEqual(len(ts), 1)
        self.assertEqual(ts[0].name, "autopilot")
        self.assertEqual(ts[0].path, "tests/run_tests")
        self.assertEqual(ts[0].command, None)
        self.assertEqual(ts[0].clicks, ['/foo/myapp.click'])
        self.assertEqual(ts[0].depends, [])
        self.assertEqual(ts[0].restrictions, [])
        self.assertEqual(ts[0].features, [])

        self.assertFalse(skipped)

    def test_invalid_json_syntax(self):
        '''parsing manifest with invalid JSON syntax'''

        with self.assertRaises(testdesc.InvalidControl) as cm:
            testdesc.parse_click_manifest('''{
  "x-test": {
    "t": { "depends": ["foo (>= 1)", }
  }}''', [], [])

        self.assertIn('not valid JSON', str(cm.exception))

    def test_invalid_json_type(self):
        '''parsing manifest with invalid JSON type'''

        with self.assertRaises(testdesc.InvalidControl) as cm:
            testdesc.parse_click_manifest('{"x-test": ["tests/foo"]}', [], [])
        self.assertIn('must be a dict', str(cm.exception))

        with self.assertRaises(testdesc.InvalidControl) as cm:
            testdesc.parse_click_manifest('{"x-test": {"t": ["tests/foo"]}}', [], [])
        self.assertIn('must be strings or dicts', str(cm.exception))

    @patch('adtlog.report')
    def test_skip_caps(self, *args):
        '''skipped test due to insufficient testbed capabilities'''

        (ts, skipped) = testdesc.parse_click_manifest('''{
  "x-test": {
    "t": {
      "path": "tests/do_t",
      "restrictions": ["needs-root"]
    }
  }
}''', ['isolation-container'], [])
        self.assertEqual(len(ts), 0)
        self.assertTrue(skipped)
        adtlog.report.assert_called_once_with(
            't', 'SKIP Test needs root on testbed which is not available')

    @patch('adtlog.report')
    def test_skip_command_and_path(self, *args):
        '''skipped test due to specifying command and path'''

        with self.assertRaises(testdesc.InvalidControl) as cm:
            testdesc.parse_click_manifest('''{
  "x-test": {
    "t": {
      "path": "tests/do_t",
      "command": "echo ok"
    }
  }
}''', [], [])
        self.assertIn('must have either path or command', str(cm.exception))

    def test_click_with_srcdir(self):
        '''parsing click with explicit source dir'''

        (srcdir, ts, skipped) = testdesc.parse_click(self.click, [],
                                                     srcdir=self.click_src)
        self.assertEqual(srcdir, self.click_src)
        self.assertEqual(len(ts), 5)
        self.assertFalse(skipped)

        # tests should be sorted alphabetically
        self.assertEqual(ts[0].name, "broken")
        self.assertEqual(ts[0].path, 'tests/printerr')
        self.assertEqual(ts[0].command, None)
        self.assertEqual(ts[0].depends, [])
        self.assertEqual(ts[0].clicks, [self.click])
        self.assertEqual(ts[0].restrictions, [])
        self.assertEqual(ts[0].features, [])

        self.assertEqual(ts[1].name, "inst")
        self.assertEqual(ts[1].path, "tests/inst")
        self.assertEqual(ts[1].command, None)
        self.assertEqual(ts[1].depends, ['python3-evdev'])
        self.assertEqual(ts[1].clicks, [self.click])
        self.assertEqual(ts[1].restrictions, [])
        self.assertEqual(ts[1].features, [])

        self.assertEqual(ts[2].name, "serr")
        self.assertEqual(ts[2].path, "tests/printerr")
        self.assertEqual(ts[2].command, None)
        self.assertEqual(ts[2].depends, [])
        self.assertEqual(ts[2].clicks, [self.click])
        self.assertEqual(ts[2].restrictions, ['allow-stderr'])
        self.assertEqual(ts[2].features, [])

        self.assertEqual(ts[3].name, "shell")
        self.assertEqual(ts[3].path, None)
        self.assertEqual(ts[3].command, 'grep ^root /etc/passwd')
        self.assertEqual(ts[3].depends, [])
        self.assertEqual(ts[3].clicks, [self.click])
        self.assertEqual(ts[3].restrictions, [])
        self.assertEqual(ts[3].features, ['bites-back'])

        self.assertEqual(ts[4].name, "simple")
        self.assertEqual(ts[4].path, "tests/simple")
        self.assertEqual(ts[4].command, None)
        self.assertEqual(ts[4].depends, [])
        self.assertEqual(ts[4].clicks, [self.click])
        self.assertEqual(ts[4].restrictions, [])
        self.assertEqual(ts[4].features, [])


if __name__ == '__main__':
    # Force encoding to UTF-8 even in non-UTF-8 locales.
    sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding="UTF-8", line_buffering=True)
    unittest.main(testRunner=unittest.TextTestRunner(stream=sys.stdout, verbosity=2))
