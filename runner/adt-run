#!/usr/bin/python2.4
#
# adt-run is part of autopkgtest
# autopkgtest is a tool for testing Debian binary packages
#
# autopkgtest is Copyright (C) 2006 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# See the file CREDITS for a full list of credits information (often
# installed as /usr/share/doc/autopkgtest/CREDITS).

import signal
import optparse
import tempfile
import sys
import subprocess
import traceback
import urllib
import string
import re as regexp
import os
import errno

from optparse import OptionParser

tmpdir = None
testbed = None
errorcode = 0

signal.signal(signal.SIGINT, signal.SIG_DFL) # undo stupid Python SIGINT thing

class Quit:
	def __init__(q,ec,m): q.ec = ec; q.m = m

def bomb(m): raise Quit(20, "unexpected error: %s" % m)
def badpkg(m): raise Quit(12, "erroneous package: %s" % m)
def report(tname, result): print '%-20s %s' % (tname, result)

class Unsupported:
 def __init__(u, lno, m):
	if lno >= 0: u.m = '%s (control line %d)' % (m, lno)
	else: u.m = m
 def report(u, tname):
	global errorcode
	errorcode != 2
	report(tname, 'SKIP %s' % u.m)

def debug(m):
	global opts
	if not opts.debug: return
	print >>sys.stderr, 'atd-run: debug:', m

def flatten(l):
	return reduce((lambda a,b: a + b), l, []) 

class Path:
 def __init__(p, tb, path, what, dir=False, tbscratch=None, xfmap=None
		lpath=None):
	p.tb = tb
	p.p = path
	p.what = what
	p.dir = dir
	p.tbscratch = tbscratch
	p.lpath = None
	if p.tb:
		if p.p[:1] != '/':
			bomb("path %s specified as being in testbed but"
				" not absolute: `%s'" % (what, p.p))
		p.local = None
		p.down = p.p
	else:
		p.local = p.p
		p.down = None
	if p.dir: p.dirsfx = '/'
	else: p.dirsfx = ''
 def path(p):
	return p.p + p.dirsfx
 def append(p, suffix, what, dir=False):
	return Path(p.tb, p.path() + suffix, what=what, dir=dir,
			tbscratch=p.tbscratch)
 def __str__(p):
	if p.tb: pfx = '/VIRT'
	elif p.p[:1] == '/': pfx = '/HOST'
	else: pfx = './'
	return pfx + p.p

 def xfmapcopy(p, cud, dstdir):
	if p.xfmap is None: return
	srcdir = os.path.dirname(p.path()+'/')
	dstdir = p.xfmapdstdir+'/'
	for f in p.xfmap(file(p.local)):
		if '/' in f: bomb("control file %s mentions other filename"
				"containing slash" % p.what)
		testbed.command(cud, (srcdir+f, dstdir+f))

 def onhost(p, lpath = None):
	if lpath is not None:
		if p.lpath is not None: assert(p.lpath == lpath)
		p.lpath = lpath
	if p.local is not None:
		if p.lpath is not None: assert(p.local == p.lpath)
		return p.local
	testbed.open()

	if p.xfmap is None:
		p.local = p.lpath
		if p.local is None: p.local = tmpdir + '/tb-' + p.what
	else:
		assert(p.lpath is None)
		assert(not p.dir)
		p.xfmapdstdir = tmpdir + '/tbd-' + p.what
		os.mkdir(p.xfmapdstdir)
		p.local = p.xfmapdstdir + '/' + os.path.basename(p.down)

	testbed.command('copyup', (p.path(), p.local + p.dirsfx))
	p.xfmapcopy('copyup')

	return p.local

 def maybe_onhost(p):
	if p.lpath is None: return None
	return p.onhost()

 def ontb(p):
	testbed.open()

	if p.tbscratch is not None:
		if p.tbscratch != testbed.scratch:
			p.down = None
	if p.down is not None: return p.down
	if p.tb:
		bomb("testbed scratch path " + str(p) + " survived testbed")

	if p.xfmap is None:
		p.down = testbed.scratch.p + '/host-' + p.what		
	else:
		assert(not p.dir)
		p.xfmapdstdir = testbed.scratch.p + '/hostd-' + p.what
		testbed.command('mkdir '+p.xfmapdstdir)
		p.down = p.xfmapdstdir + '/' + os.path.basename(p.local)

	p.tbscratch = testbed.scratch
	testbed.command('copydown', (p.path(), p.down + p.dirsfx))
	p.xfmapcopy('copydown')
	return p.down

def parse_args():
	global opts
	usage = "%prog <options> -- <virt-server>..."
	parser = OptionParser(usage=usage)
	pa = parser.add_option
	pe = parser.add_option

	def cb_vserv(op,optstr,value,parser):
		parser.values.vserver = list(parser.rargs)
		del parser.rargs[:]

	def cb_path(op,optstr,value,parser, long,tb,dir,xfmap):
		name = long.replace('-','_')
		path = Path(tb, value, long, dir, xfmap=xfmap)
		setattr(parser.values, name, path)

	def pa_path(long, help, dir=False, xfmap=None):
		def papa_tb(long, ca, pahelp):
			pa('', long, action='callback', callback=cb_path,
				nargs=1, type='string', callback_args=ca,
				help=(help % pahelp), metavar='PATH')
		papa_tb('--'+long,	(long, False, dir, xfmap), 'host')
		papa_tb('--'+long+'-tb',(long, True, dir, xfmap), 'testbed')

	pa_path('tests-tree',		'TREE',	'use tests in build tree TREE (found on %s)',			dir=True)

	pa_pkg('source',		'DSC',	'build DSC (on %s) on testbed and use its tests and packages',	testsrc=True, pkgsrc=True)
	pa_pkg('source-tests',		'DSC',	'use tests in DSC (found on %s), building it on testbed',	testsrc=True, pkgsrc=False)
	pa_pkg('source-testsinstall',	'DSC',	'build DSC (found on %s), use its tests, and install its'
						' binaries (even when apparently not required)',		testsrc=True, pkgsrc='*')

	pa_pkg('source-binaries',	'DSC',	'build DSC (on %s) on testbed and use its binary packages'
						' as test targets and to satisfy dependencies',			testsrc=False, pkgsrc=True)
	pa_pkg('source-installbinaries','DSC', 'build DSC (on %s) on testbed and install its binary'
						' packages (even when apparently not required)',		testsrc=False, pkgsrc='*')

	pa_pkg('install-binary',	'DEB',	'install package DEB (found on %s) on testbed',			testsrc=None, pkgsrc=None)


	#nyi pa_path('install-from-source', 'build and install package found'+
	#			' in PATH on %s', xfmap=xfmap_dsc)
	#nyi these install-* options need cb_path to be able to make a list
	# nyi: without-depends,with-depends-only,with-depends,with-recommends
	# nyi: package-filter-dependency
	# nyi: package-filter-from-source
	pa_path('install-binary', 'build source package PATH on %s')
	pa_path('control',    'read control file PATH on %s')
	pa_path('output-dir', 'write stderr/out files in PATH on %s', dir=True)

	pa('','--user',			help=	'run tests as USER (needs root on testbed)',			type='string', dest='user')
	pa('','--fakeroot',		help=	'prefix debian/rules build with FAKEROOT'			type='string', dest='fakeroot')
	pa('-d', '--debug', action='store_true', dest='debug');

	class SpecialOption(optparse.Option): pass
	vs_op = SpecialOption('','--VSERVER-DUMMY')
	vs_op.action = 'callback'
	vs_op.type = None
	vs_op.default = None
	vs_op.nargs = 0
	vs_op.callback = cb_vserv
	vs_op.callback_args = ( )
	vs_op.callback_kwargs = { }
	vs_op.help = 'introduces virtualisation server and args'
	vs_op._short_opts = []
	#vs_op._long_opts = ['--DUMMY']
	vs_op._long_opts = ['---']

	pa(vs_op)

	(opts,args) = parser.parse_args()
	if not hasattr(opts,'vserver'):
		parser.error('you must specifiy --- <virt-server>...')

	if opts.tests_tree is not None and opts.build_source is not None:
		parser.error('do not specify both --build-tree and'
				' --build-source')

	if opts.control is None:
		opts.control = opts.tests_tree.append(
			'debian/tests/control', 'control')

def finalise_options():
	global opts, testbed

	if opts.tests_tree is None and opts.build_source is None:
		opts.tests_tree = Path(False, '.', 'build-tree', dir=True)

	if opts.user is None and 'root-on-testbed' not in caps:
		opts.user = ''

	if opts.user is None:
		su = 'suggested-normal-user='
		ul = [
			e[length(su):]
			for e in caps
			if e.startswith(su)
			]
		if len(ul) > 1:
			print >>sys.stderr, "warning: virtualisation"
				" system offers several suggested-normal-user"
				" values: "+('/'.join(ul))+", using "+ul[0]
		if ul:
			opts.user = ul[0]
		else:
			opts.user = ''

	if opts.user:
		if 'root-on-testbed' not in caps:
			print >>sys.stderr, "warning: virtualisation"
				" system does not offer root on testbed,"
				" but --user option specified: failure likely"
		opts.user_wrap = lambda x: 'su %s -c "%s"' % (opts.user, x)
	else:
		opts.user_wrap = lambda x: x

	if opts.fakeroot is None:
		opts.fakeroot = ''
		if opts.user or
		   'root-on-testbed' not in testbed.caps:
			opts.fakeroot = 'fakeroot'

logpath_counters = {}

def logpath(idstr):
	# if idstr ends with `-' then a counter is appended
	if idstr.endswith('-'):
		if not logpath_counters.has_key(idstr):
			logpath_counters[idstr] = 1
		else:
			logpath_counters[idstr] += 1
		idstr.append(`logpath_counters[idstr]`)
	idstr = 'log-' + idstr
	if opts.output_dir is None:
		return testbed.scratch.append(idstr, idstr)
	elif opts.output_dir.tb:
		return opts.output_dir.append(idstr, idstr)
	else:
		return Path(True, testbed.scratch.p, idstr,
			lpath=opts.output_dir.p+'/'+idstr)

class Testbed:
 def __init__(tb):
	tb.sp = None
	tb.lastsend = None
	tb.scratch = None
 def start(tb):
	p = subprocess.PIPE
	tb.sp = subprocess.Popen(opts.vserver,
		stdin=p, stdout=p, stderr=None)
	tb.expect('ok')
	tb.caps = tb.command('capabilities')
 def stop(tb):
	tb.close()
	if tb.sp is None: return
	ec = tb.sp.returncode
	if ec is None:
		tb.sp.stdout.close()
		tb.send('quit')
		tb.sp.stdin.close()
		ec = tb.sp.wait()
	if ec:
		tb.bomb('testbed gave exit status %d after quit' % ec)
 def open(tb):
	if tb.scratch is not None: return
	p = tb.commandr1('open')
	tb.scratch = Path(True, p, 'tb-scratch', dir=True)
	tb.scratch.tbscratch = tb.scratch
 def close(tb):
	if tb.scratch is None: return
	tb.scratch = None
	if tb.sp is None: return
	tb.command('close')
 def bomb(tb, m):
	if tb.sp is not None:
		tb.sp.stdout.close()
		tb.sp.stdin.close()
		ec = tb.sp.wait()
		if ec: print >>sys.stderr, ('adt-run: testbed failing,'
			' exit status %d' % ec)
	tb.sp = None
	raise Quit(16, 'testbed failed: %s' % m)
 def send(tb, string):
	tb.sp.stdin
	try:
		debug('>> '+string)
		print >>tb.sp.stdin, string
		tb.sp.stdin.flush()
		tb.lastsend = string
	except:
		(type, value, dummy) = sys.exc_info()
		tb.bomb('cannot send to testbed: %s' % traceback.
			format_exception_only(type, value))
 def expect(tb, keyword, nresults=-1):
	l = tb.sp.stdout.readline()
	if not l: tb.bomb('unexpected eof from the testbed')
	if not l.endswith('\n'): tb.bomb('unterminated line from the testbed')
	l = l.rstrip('\n')
	debug('<< '+l)
	ll = l.split()
	if not ll: tb.bomb('unexpected whitespace-only line from the testbed')
	if ll[0] != keyword:
		if tb.lastsend is None:
			tb.bomb("got banner `%s', expected `%s...'" %
				(l, keyword))
		else:
			tb.bomb("sent `%s', got `%s', expected `%s...'" %
				(tb.lastsend, l, keyword))
	ll = ll[1:]
	if nresults >= 0 and len(ll) != nresults:
		tb.bomb("sent `%s', got `%s' (%d result parameters),"
			" expected %d result parameters" %
			(string, l, len(ll), nresults))
	return ll
 def commandr(tb, cmd, nresults, args=()):
	if type(cmd) is str: cmd = [cmd]
	al = cmd + map(urllib.quote, args)
	tb.send(string.join(al))
	ll = tb.expect('ok')
	rl = map(urllib.unquote, ll)
	return rl
 def command(tb, cmd, args=()):
	tb.commandr(cmd, 0, args)
 def commandr1(tb, cmd, args=()):
	rl = tb.commandr(cmd, 1, args)
	return rl[0]

class FieldBase:
 def __init__(f, fname, stz, base, tnames, vl):
	assert(vl)
	f.stz = stz
	f.base = base
	f.tnames = tnames
	f.vl = vl
 def words(f):
	def distribute(vle):
		(lno, v) = vle
		r = v.split()
		r = map((lambda w: (lno, w)), r)
		return r
	return flatten(map(distribute, f.vl))
 def atmostone(f):
	if len(vl) == 1:
		(f.lno, f.v) = vl[0]
	else:
		raise Unsupported(f.vl[1][0],
			'only one %s field allowed' % fn)
	return f.v

def build_some_source(keyletter, dsc, binaries=False):
	idstr = 'build'+keyletter
	testbed.open()
	bd = testbed.scratch.append(idstr, idstr)
	script = [
			'exec 3>&1 >&2'
			'mkdir '+bd.ontb(),
			'cd '+bd.ontb(),
			'dpkg-source -x '+dsc.ontb()+' >&2',
			'cd */.',
			'pwd >&3',
			opts.user_wrap('debian/rules build'),
			]
	if binaries:
		script = script + [
			opts.user_wrap(opts.fakeroot+' debian/rules binary'),
			'cd ..',
			'echo *.deb >&3',
			]

	script = '\n'.join(script)
	so = testbed.scratch.append(idstr+'-tree-path')
	se = logpath('log-'+idstr)
	rc = testbed.commandr1(['execute',
		','.join(map(urllib.quote, ['sh','-xec',script]))],
		'/dev/null',so.ontb(),se.ontb(), testbed.scratch.ontb())
	sod = file(so.onhost()).read().split("\n")
	tests_tree = Path(True, sod[0], idstr+'-tree', dir=True)
	se.maybe_onhost()
	return (tests_tree,)

def acquire_built_source():
	global opts

	if opts.build_source:
		assert(opts.tests_tree is None)
		bss = build_some_source('t', opts.build_source)
		opts.tests_tree = bss[0]

class FieldIgnore(FieldBase):
 def parse(f): pass

class Restriction:
 def __init__(r,rname,base): pass

class Restriction_rw_tests_tree(Restriction): pass

class Field_Restrictions(FieldBase):
 def parse(f):
	for wle in f.words():
		(lno, rname) = wle
		rname = rname.replace('-','_')
		try: rclass = globals()['Restriction_'+rname]
		except KeyError: raise Unsupported(lno,
			'unknown restriction %s' % rname)
		r = rclass(rname, f.base)
		f.base['restrictions'].append(r)

class Field_Tests(FieldIgnore): pass

class Field_Tests_directory(FieldBase):
 def parse(f):
	td = atmostone(f)
	if td.startswith('/'): raise Unspported(f.lno,
		'Tests-Directory may not be absolute')
	base['testsdir'] = td

def run_tests():
	for t in tests:
		t.run()
	if not tests:
		global errorcode
		report('*', 'SKIP no tests in this package')
		errorcode |= 8

class Test:
 def __init__(t, tname, base):
	if '/' in tname: raise Unsupported(base[' lno'],
		'test name may not contain / character')
	for k in base: setattr(t,k,base[k])
	t.tname = tname
	if len(base['testsdir']): tpath = base['testsdir'] + '/' + tname
	else: tpath = tname
	t.p = opts.tests_tree.append(tpath, 'test-'+tname)
 def report(t, m):
	report(t.tname, m)
 def reportfail(t, m):
	global errorcode
	errorcode |= 4
	report(t.tname, 'FAIL ' + m)
 def run(t):
	testbed.open()
	def stdouterr(oe):
		idstr = oe + '-' + t.tname
		if opts.output_dir is not None and opts.output_dir.tb:
			return opts.output_dir.append(idstr)
		else:
			return testbed.scratch.append(idstr, idstr)
	def stdouterrh(p, oe):
		idstr = oe + '-' + t.tname
		if opts.output_dir is None or opts.output_dir.tb:
			return p.onhost()
		else:
			return p.onhost(opts.output_dir.onhost() + '/' + idstr)
	so = stdouterr('stdout')
	se = stdouterr('stderr')
	rc = testbed.commandr1('execute',(t.p.ontb(),
		'/dev/null', so.ontb(), se.ontb(), opts.tests_tree.ontb()))
	soh = stdouterrh(so, 'stdout')
	seh = stdouterrh(se, 'stderr')
	rc = int(rc)
	stab = os.stat(seh)
	if stab.st_size != 0:
		l = file(seh).readline()
		l = l.rstrip('\n \t\r')
		if len(l) > 40: l = l[:40] + '...'
		t.reportfail('stderr: %s' % l)
	elif rc != 0:
		t.reportfail('non-zero exit status %d' % rc)
	else:
		t.report('PASS')

def read_control():
	global tests
	try:
		control = file(opts.control.onhost(), 'r')
	except IOError, oe:
		if oe[0] != errno.ENOENT: raise
		tests = []
		return
	lno = 0
	def badctrl(m): testbed.badpkg('tests/control line %d: %s' % (lno, m))
	stz = None # stz[field_name][index] = (lno, value)

	stanzas = [ ]
	stz = None

	def end_stanza(stz):
		if stz is None: return
		stz[' errs'] = 0
		stanzas.append(stz)
		stz = None
		hcurrent = None

	initre = regexp.compile('([A-Z][-0-9a-z]*)\s*\:\s*(.*)$')
	while 1:
		l = control.readline()
		if not l: break
		lno += 1
		if not l.endswith('\n'): badctrl('unterminated line')
		if regexp.compile('\s*\#').match(l): continue
		if not regexp.compile('\S').match(l): end_stanza(stz); continue
		initmat = initre.match(l)
		if initmat:
			(fname, l) = initmat.groups()
			fname = string.capwords(fname)
			if stz is None:
				stz = { ' lno': lno }
			if not stz.has_key(fname): stz[fname] = [ ]
			hcurrent = stz[fname]
		elif regexp.compile('\s').match(l):
			if not hcurrent: badctrl('unexpected continuation')
		else:
			badctrl('syntax error')
		hcurrent.append((lno, l))
	end_stanza(stz)

	def testbadctrl(stz, lno, m):
		report_badctrl(lno, m)
		stz[' errs'] += 1

	for stz in stanzas:
		try:
			try: tnames = stz['Tests']
			except KeyError:
				tnames = ['*']
				raise Unsupported(stz[' lno'],
					'no Tests field')
			tnames = map((lambda lt: lt[1]), tnames)
			tnames = string.join(tnames).split()
			base = {
				'restrictions': [],
				'testsdir': 'debian/tests'
			}
			for fname in stz.keys():
				if fname.startswith(' '): continue
				vl = stz[fname]
				try: fclass = globals()['Field_'+
					fname.replace('-','_')]
				except KeyError: raise Unsupported(vl[0][0],
					'unknown metadata field %s' % fname)
				f = fclass(stz, fname, base, tnames, vl)
				f.parse()
			tests = []
			for tname in tnames:
				t = Test(tname, base)
				tests.append(t)
		except Unsupported, u:
			for tname in tnames: u.report(tname)
			continue

def print_exception(ei, msgprefix=''):
	if msgprefix: print >>sys.stderr, msgprefix
	(et, q, tb) = ei
	if et is Quit:
		print >>sys.stderr, 'adt-run:', q.m
		return q.ec
	else:
		print >>sys.stderr, "adt-run: unexpected, exceptional, error:"
		traceback.print_exc()
		return 20

def cleanup():
	try:
		rm_ec = 0
		if tmpdir is not None:
			rm_ec = subprocess.call(['rm','-rf','--',tmpdir])
		if testbed is not None:
			testbed.stop()
		if rm_ec: bomb('rm -rf -- %s failed, code %d' % (tmpdir, ec))
	except:
		print_exception(sys.exc_info(),
			'\nadt-run: error cleaning up:\n')
		os._exit(20)

def main():
	global testbed
	global tmpdir
	try:
		parse_args()
	except SystemExit, se:
		os._exit(20)
	try:
		tmpdir = tempfile.mkdtemp()
		testbed = Testbed()
		testbed.start()
		testbed.open()
		testbed.close()
		finalise_options()
		read_control()
		run_tests()
	except:
		ec = print_exception(sys.exc_info(), '')
		cleanup()
		os._exit(ec)
	cleanup()
	os._exit(errorcode)

main()
