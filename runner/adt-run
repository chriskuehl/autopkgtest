#!/usr/bin/python2.4
#
# adt-run is part of autopkgtest
# autopkgtest is a tool for testing Debian binary packages
#
# autopkgtest is Copyright (C) 2006 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# See the file CREDITS for a full list of credits information (often
# installed as /usr/share/doc/autopkgtest/CREDITS).

import signal
import optparse
import tempfile
import sys
import subprocess
import traceback
import urllib
import string
import re as regexp
import os
import errno
import fnmatch
import shutil
import copy

from optparse import OptionParser
signal.signal(signal.SIGINT, signal.SIG_DFL) # undo stupid Python SIGINT thing

#---------- global variables

tmpdir = None		# pathstring on host
testbed = None		# Testbed
errorcode = 0		# exit status that we are going to use
binaries = None		# Binaries (.debs we have registered)

#---------- errors we define

class Quit:
	def __init__(q,ec,m): q.ec = ec; q.m = m

def bomb(m, se=''):
	print >>sys.stderr, se
	raise Quit(20, "unexpected error: %s" % m)

def badpkg(m, se=''):
	print >>sys.stderr, se
	print 'blame: ', ' '.join(testbed.blamed)
	raise Quit(12, "erroneous package: %s" % m)

def report(tname, result): print '%-20s %s' % (tname, result)

class Unsupported:
 def __init__(u, lno, m):
	if lno >= 0: u.m = '%s (control line %d)' % (m, lno)
	else: u.m = m
 def report(u, tname):
	global errorcode
	errorcode != 2
	report(tname, 'SKIP %s' % u.m)

def debug(m):
	global opts
	if not opts.debug: return
	for l in m.rstrip('\n').split('\n'):
		print >>sys.stderr, 'atd-run: debug:', l

def mkdir_okexist(pathname, mode=02755):
	try:
		os.mkdir(pathname, mode)
	except OSError, oe:
		if oe.errno != errno.EEXIST: raise

def rmtree(what, pathname):
	debug('/ %s rmtree %s' % (what, pathname))
	shutil.rmtree(pathname)

def debug_subprocess(what, cmdl=None, script=None):
	o = '$ '+what+':'
	if cmdl is not None:
		ol = []
		for x in cmdl:
			if x is script: x = '<SCRIPT>'
			ol.append(x.	replace('\\','\\\\').
					replace(' ','\\ ')	)
		o += ' '+ ' '.join(ol)
	if script is not None:
		o += '\n'
		for l in script.rstrip('\n').split('\n'):
			o += '$     '+l+'\n'
	debug(o)

def flatten(l):
	return reduce((lambda a,b: a + b), l, []) 

#---------- fancy automatic file-copying class

class AutoFile:
	# p.what
	# p.path[tb]	None or path	not None => path known
	# p.file[tb]	None or path	not None => file exists
	# p.spec	string or None
	# p.spec_tbp	True or False, or not set if spec is None
	# p.dir		'' or '/'

 def __init__(p, what):
	p.what = what
	p.path = [None,None]
	p.file = [None,None]
	p.spec = None
	p.dir = ''

 def __str__(p):
	def ptbp(tbp):
		if p.path[tbp] is None: return '-'+p.dir
		elif p.file[tbp] is None: return p.path[tbp]+p.dir+'?'
		else: return p.path[tbp]+p.dir+'!'
	out = p.what
	if p.spec is not None:
		if p.spec_tbp: out += '#'
		else: out += '='
		out += p.spec
	out += ':'
	out += ptbp(False)
	out += '|'
	out += ptbp(True)
	return out

 def _wrong(p, how):
	xtra = ''
	if p.spec is not None: xtra = ' spec[%s]=%s' % (p.spec, p.spec_tb)
	raise ("internal error: %s (%s)" % (how, str(p)))

 def _ensure_path(p, tbp):
	if p.path[tbp] is None:
		if '/' in p.what:
			p._debug('tmp-parent %s...' % 'HT'[tbp])
			TemporaryDir(os.path.dirname(p.what)).write(tbp)
		if not tbp:
			p.path[tbp] = tmpdir+'/'+p.what
		else:
			p.path[tbp] = testbed.scratch.path[True]+'/'+p.what

 def write(p, tbp=False):
	p._debug('write %s...' % 'HT'[tbp])
	p._ensure_path(tbp)

	if p.dir and not p.file[tbp]:
		if not tbp:
			p._debug('mkdir H')
			mkdir_okexist(p.path[tbp])
		else:
			cmdl = ['sh','-ec',
				'test -d "$1" || mkdir -p "$1"',
				'x', p.path[tbp]]
			tf_what = urllib.quote(p.what).replace('/','%2F')
			(rc,se) = testbed.execute('mkdir-'+tf_what, cmdl)
			if rc: bomb('failed to create directory %s' %
				p.path[tbp], se)

	p.file[tbp] = p.path[tbp]
	return p.path[tbp]

 def read(p, tbp=False):
	p._debug('read %s...' % 'HT'[tbp])
	p._ensure_path(tbp)

	if p.file[tbp] is None:
		if p.file[not tbp] is None:
			p._wrong("requesting read but nonexistent")
		cud = ['copyup','copydown'][tbp]
		src = p.file[not tbp] + p.dir
		dst = p.path[tbp] + p.dir
		testbed.command(cud, (src, dst))
		p.file[tbp] = p.path[tbp]

	return p.file[tbp] + p.dir

 def invalidate(p, tbp=False):
	p.file[tbp] = None
	p._debug('invalidated %s' % 'HT'[tbp])

 def _debug(p, m):
	debug('/ %s#%x: %s' % (p.what, id(p), m))

 def _constructed(p):
	p._debug('constructed: '+str(p))
	p._check()

 def _check(p):
	for tbp in [False,True]:
	 for pf in [p.path, p.file]:
		if pf[tbp] is None: continue
		if not pf[tbp]: bomb('empty path specified for '+p.what)
		if p.dir and pf[tbp].endswith('/'):
			pf[tbp] = pf[tbp].rstrip('/')
			if not pf[tbp]: pf[tbp] = '/'
		if not p.dir and pf[tbp].endswith('/'):
			bomb("directory `%s' specified for "
			     "non-directory %s" % (pf[tbp], p.what))

 def _relative_init(p, what, parent, leaf, onlyon_tbp, setfiles, sibling):
	AutoFile.__init__(p,what)
	sh_on = ''; sh_sibl = ''
	if onlyon_tbp is not None: sh_on = ' (on %s)' % ('HT'[onlyon_tbp])
	if sibling: sh_sibl=' (sibling)'
	parent._debug('using as base: %s: %s%s%s' %
			(str(parent), leaf, sh_on, sh_sibl))
	if not sibling and not parent.dir:
		parent._wrong('asked for non-sibling relative path of non-dir')
	if sibling: trim = os.path.dirname
	else: trim = lambda x: x
	for tbp in [False,True]:
		if parent.path[tbp] is None: continue
		trimmed = trim(parent.path[tbp])
		if trimmed: trimmed += '/'
		p.path[tbp] = trimmed + leaf
		if setfiles and (onlyon_tbp is None or onlyon_tbp == tbp):
			p.file[tbp] = p.path[tbp]

class InputFile(AutoFile):
 def _init(p, what, spec, spec_tbp=False):
	AutoFile.__init__(p, what)
	p.spec = spec
	p.spec_tbp = spec_tbp
	p.path[spec_tbp] = spec
	p.file[p.spec_tbp] = p.path[p.spec_tbp]
 def __init__(p, what, spec, spec_tbp=False):
	p._init(what,spec,spec_tbp)
	p._constructed()

class InputDir(InputFile):
 def __init__(p, what, spec, spec_tbp=False):
	InputFile._init(p,what,spec,spec_tbp)
	p.dir = '/'
	p._constructed()

class OutputFile(AutoFile):
 def _init(p, what, spec, spec_tbp=False):
	AutoFile.__init__(p, what)
	p.spec = spec
	p.spec_tbp = spec_tbp
	p.path[spec_tbp] = spec
 def __init__(p, what, spec, spec_tbp=False):
	p._init(what,spec,spec_tbp)
	p._constructed()

class OutputDir(OutputFile):
 def __init__(p, what, spec, spec_tbp=False):
	OutputFile._init(p,what,spec,spec_tbp)
 	p.dir = '/'
	p._constructed()

class RelativeInputFile(AutoFile):
 def __init__(p, what, parent, leaf, onlyon_tbp=None, sibling=False):
	p._relative_init(what, parent, leaf, onlyon_tbp, True, sibling)
	p._constructed()

class RelativeOutputFile(AutoFile):
 def __init__(p, what, parent, leaf, sibling=False):
	p._relative_init(what, parent, leaf, None, False, sibling)
	p._constructed()

class TemporaryFile(AutoFile):
 def __init__(p, what):
	AutoFile.__init__(p, what)
	p._constructed()

class TemporaryDir(AutoFile):
 def __init__(p, what):
	AutoFile.__init__(p, what)
	p.dir = '/'
	p._constructed()

#---------- parsing and representation of the arguments

class Action:
 def __init__(a, kind, af, arghandling, what):
	# extra attributes get added during processing
	a.kind = kind
	a.af = af
	a.ah = arghandling
	a.what = what

def parse_args():
	global opts
	usage = "%prog <options> --- <virt-server>..."
	parser = OptionParser(usage=usage)
	pa = parser.add_option
	pe = parser.add_option

	arghandling = {
		'dsc_tests': True,
		'dsc_filter': '*',
		'deb_forbuilds': 'auto',
		'deb_fortests': 'auto',
		'tb': False,
		'override_control': None
	}
	initial_arghandling = arghandling.copy()
	n_non_actions = 0

	#----------
	# actions (ie, test sets to run, sources to build, binaries to use):

	def cb_action(op,optstr,value,parser, long,kindpath,is_act):
		print >>sys.stderr, "cb_action", is_act
		parser.largs.append((value,kindpath))
		n_non_actions += not(is_act)

	def pa_action(long, metavar, kindpath, help, is_act=True):
		pa('','--'+long, action='callback', callback=cb_action,
			nargs=1, type='string',
			callback_args=(long,kindpath,is_act), help=help)

	pa_action('build-tree',		'TREE', '@/',
		help='run tests from build tree TREE')

	pa_action('source',		'DSC', '@.dsc',
		help='build DSC and use its tests and/or'
		    ' generated binary packages')

	pa_action('binary',		'DEB', '@.deb',
	       help='use binary package DEB according'
		    ' to most recent --binaries-* settings')

	pa_action('override-control',	'CONTROL', ('control',), is_act=0,
	       help='run tests from control file CONTROL instead,'
		    ' (applies to next test suite only)')

	#----------
	# argument handling settings (what ways to use action
	#  arguments, and pathname processing):

	def cb_setah(option, opt_str, value, parser, toset,setval):
		if type(setval) == list:
			if not value in setval:
				parser.error('value for %s option (%s) is not '
				 'one of the permitted values (%s)' %
				 (value, opt_str, setval.join(' ')))
		elif setval is not None:
			value = setval
		for v in toset:
			arghandling[v] = value
		parser.largs.append(arghandling.copy())

	def pa_setah(long, affected,effect, metavar=None, **kwargs):
		type = metavar
		if type is not None: type = 'string'
		pa('',long, action='callback', callback=cb_setah,
		   callback_args=(affected,effect), **kwargs)

	#---- paths: host or testbed:
	#
	pa_setah('--paths-testbed', ['tb'],True,
		help='subsequent path specifications refer to the testbed')
	pa_setah('--paths-host', ['tb'],False,
		help='subsequent path specifications refer to the host')

	#---- source processing settings:

	pa_setah('--sources-tests', ['dsc_tests'],True,
		help='run tests from builds of subsequent sources')
	pa_setah('--sources-no-tests', ['dsc_tests'],False,
		help='do not run tests from builds of subsequent sources')

	pa_setah('--built-binaries-filter', ['dsc_filter'],None,
		type='string', metavar='PATTERN-LIST',
		help='from subsequent sources, use binaries matching'
		     ' PATTERN-LIST (comma-separated glob patterns)'
		     ' according to most recent --binaries-* settings')
	pa_setah('--no-built-binaries', ['dsc_filter'], '_',
		help='from subsequent sources, do not use any binaries')

	#---- binary package processing settings:

	def pa_setahbins(long,toset,how):
	 pa_setah(long, toset,['ignore','auto','install'],
		type='string', metavar='IGNORE|AUTO|INSTALL', default='auto',
		help=how+' ignore binaries, install them as needed'
			' for dependencies, or unconditionally install'
			' them, respectively')
	pa_setahbins('--binaries', ['deb_forbuilds','deb_fortests'], '')
	pa_setahbins('--binaries-forbuilds', ['deb_forbuilds'], 'for builds, ')
	pa_setahbins('--binaries-fortests', ['deb_fortests'], 'for tests, ')

	#----------
	# general options:

	def cb_vserv(op,optstr,value,parser):
		parser.values.vserver = list(parser.rargs)
		del parser.rargs[:]

	def cb_path(op,optstr,value,parser, constructor,long,dir):
		name = long.replace('-','_')
		af = constructor(arghandling['tb'], value, long, dir)
		setattr(parser.values, name, af)

	def pa_path(long, constructor, help, dir=False):
		pa('','--'+long, action='callback', callback=cb_path,
			callback_args=(constructor,long,dir),
			nargs=1, type='string',
			help=help, metavar='PATH')

	pa_path('output-dir', OutputDir, dir=True,
		help='write stderr/out files in PATH')

	pa('','--tmp-dir', 		type='string', dest='tmpdir',
		help='write temporary files to TMPDIR, emptying it'
		     ' beforehand and leaving it behind at the end')

	pa('','--user',			type='string', dest='user',
		help='run tests as USER (needs root on testbed)')
	pa('','--gain-root',		type='string', dest='gainroot',
		help='prefix debian/rules binary with GAINROOT')
	pa('-d', '--debug', action='store_true', dest='debug');
	pa('','--gnupg-home',		type='string', dest='gnupghome',
		default='~/.autopkgtest/gpg',
		help='use GNUPGHOME rather than ~/.autopkgtest (for'
			" signing private apt archive);"
			" `fresh' means generate new key each time.")

	#----------
	# actual meat:

	class SpecialOption(optparse.Option): pass
	vs_op = SpecialOption('','--VSERVER-DUMMY')
	vs_op.action = 'callback'
	vs_op.type = None
	vs_op.default = None
	vs_op.nargs = 0
	vs_op.callback = cb_vserv
	vs_op.callback_args = ( )
	vs_op.callback_kwargs = { }
	vs_op.help = 'introduces virtualisation server and args'
	vs_op._short_opts = []
	vs_op._long_opts = ['---']

	pa(vs_op)

	(opts,args) = parser.parse_args()
	if not hasattr(opts,'vserver'):
		parser.error('you must specifiy --- <virt-server>...')
	if n_non_actions >= len(parser.largs):
		parser.error('nothing to do specified')

	arghandling = initial_arghandling
	opts.actions = []
	ix = 0
	for act in args:
		if type(act) == dict:
			arghandling = act
			continue
		elif type(act) == tuple:
			pass
		elif type(act) == str:
			act = (act,act)
		else:
			raise ("unknown action in list `%s' having"
			      " type `%s'" % (act, type(act)))
		(pathstr, kindpath) = act

		constructor = InputFile
		if type(kindpath) is tuple:		kind = kindpath[0]
		elif kindpath.endswith('.deb'):		kind = 'deb'
		elif kindpath.endswith('.dsc'):		kind = 'dsc'
		elif kindpath.endswith('/'):
			kind = 'tree'
			constructor = InputDir
		else: parser.error("do not know how to handle filename \`%s';"
			" specify --source --binary or --build-tree")

		what = '%s%s' % (kind,ix); ix += 1

		if kind == 'dsc': fwhatx = '/' + os.path.basename(pathstr)
		else: fwhatx = '-'+kind

		af = constructor(what+fwhatx, pathstr, arghandling['tb'])
		opts.actions.append(Action(kind, af, arghandling, what))

def finalise_options():
	global opts, tb, tmpdir

	if opts.tmpdir is not None:
		rmtree('tmpdir(specified)',opts.tmpdir)
		mkdir_okexist(opts.tmpdir, 0700)
		tmpdir = opts.tmpdir
	else:
		assert(tmpdir is None)
		tmpdir = tempfile.mkdtemp()

	if opts.user is None and 'root-on-testbed' not in testbed.caps:
		opts.user = ''

	if opts.user is None:
		su = 'suggested-normal-user='
		ul = [
			e[len(su):]
			for e in testbed.caps
			if e.startswith(su)
			]
		if ul:
			opts.user = ul[0]
		else:
			opts.user = ''

	if opts.user:
		if 'root-on-testbed' not in testbed.caps:
			print >>sys.stderr, ("warning: virtualisation"
				" system does not offer root on testbed,"
				" but --user option specified: failure likely")
		opts.user_wrap = lambda x: "su %s -c '%s'" % (opts.user, x)
	else:
		opts.user_wrap = lambda x: x

	if opts.gainroot is None:
		opts.gainroot = ''
		if (opts.user or
		    'root-on-testbed' not in testbed.caps):
			opts.gainroot = 'fakeroot'

	if opts.gnupghome.startswith('~/'):
		try: home = os.environ['HOME']
		except KeyError:
			parser.error("HOME environment variable"
				" not set, needed for --gnupghome=`%s"
				% opts.gnupghome)
		opts.gnupghome = home + opts.gnupghome[1:]
	elif opts.gnupghome == 'fresh':
		opts.gnupghome = None

#---------- testbed management - the Testbed class

class Testbed:
 def __init__(tb):
	tb.sp = None
	tb.lastsend = None
	tb.scratch = None
	tb.modified = False
	tb.blamed = []
	tb._ephemeral = []
	tb._debug('init')
 def _debug(tb, m):
	debug('** '+m)
 def start(tb):
	tb._debug('start')
	p = subprocess.PIPE
	debug_subprocess('vserver', opts.vserver)
	tb.sp = subprocess.Popen(opts.vserver,
		stdin=p, stdout=p, stderr=None)
	tb.expect('ok')
	tb.caps = tb.commandr('capabilities')
	tb._need_reset_apt = False
 def stop(tb):
	tb._debug('stop')
	tb.close()
	if tb.sp is None: return
	ec = tb.sp.returncode
	if ec is None:
		tb.sp.stdout.close()
		tb.send('quit')
		tb.sp.stdin.close()
		ec = tb.sp.wait()
	if ec:
		tb.bomb('testbed gave exit status %d after quit' % ec)
 def open(tb):
	tb._debug('open, scratch=%s' % tb.scratch)
	if tb.scratch is not None: return
	pl = tb.commandr('open')
	tb.scratch = InputDir('tb-scratch', pl[0], True)
	tb.deps_processed = []
 def mungeing_apt(tb):
	if not 'revert' in tb.caps:
		tb._need_reset_apt = True
 def reset_apt(tb):
	if not tb._need_reset_apt: return
	what = 'aptget-update-reset'
	cmdl = ['apt-get','-qy','update']
	(rc,se) = tb.execute(what, cmdl)
	if rc:
		print >>sys.stderr, se, ("\n" "warning: failed to restore"
				" testbed apt cache, exit code %d" % rc)
	tb._need_reset_apt = False
 def close(tb):
	tb._debug('close, scratch=%s' % tb.scratch)
	if tb.scratch is None: return
	tb.scratch = None
	if tb.sp is None: return
	tb.command('close')
 def prepare(tb, deps_new):
	tb._debug('prepare, modified=%s, deps_processed=%s, deps_new=%s' %
		(tb.modified, tb.deps_processed, deps_new))
	if 'revert' in tb.caps and (tb.modified or
	    [d for d in tb.deps_processed if d not in deps_new]):
		tb._debug('reset **')
		tb.command('revert')
		tb.blamed = []
		for af in tb._ephemeral: af.invalidate(True)
	binaries.publish()
	tb.modified = False
	tb._install_deps(deps_new)
 def register_ephemeral(tb, af):
	tb._ephemeral.append(af)
 def _install_deps(tb, deps_new):
	tb._debug(' installing dependencies '+`deps_new`)
	tb.deps_processed = deps_new
	if not deps_new: return
	dstr = ', '.join(deps_new)
	script = binaries.apt_pkg_gdebi_script(
		dstr, [[
		'from GDebi.DebPackage import DebPackage',
		'd = DebPackage(cache)',
		'res = d.satisfyDependsStr(arg)',
		]])
	cmdl = ['python','-c',script]
	what = 'install-deps'
	debug_subprocess(what, cmdl, script=script)
	(rc,se) = testbed.execute(what, cmdl)
	if rc: badpkg('dependency install failed, exit code %d' % rc, se)
 def needs_reset(tb):
	tb._debug('needs_reset, previously=%s' % tb.modified)
	tb.modified = True
 def blame(tb, m):
	tb._debug('blame += %s' % m)
	tb.blamed.append(m)
 def bomb(tb, m):
	tb._debug('bomb %s' % m)
	if tb.sp is not None:
		tb.sp.stdout.close()
		tb.sp.stdin.close()
		ec = tb.sp.wait()
		if ec: print >>sys.stderr, ('adt-run: testbed failing,'
			' exit status %d' % ec)
	tb.sp = None
	raise Quit(16, 'testbed failed: %s' % m)
 def send(tb, string):
	tb.sp.stdin
	try:
		debug('>> '+string)
		print >>tb.sp.stdin, string
		tb.sp.stdin.flush()
		tb.lastsend = string
	except:
		(type, value, dummy) = sys.exc_info()
		tb.bomb('cannot send to testbed: %s' % traceback.
			format_exception_only(type, value))
 def expect(tb, keyword, nresults=None):
	l = tb.sp.stdout.readline()
	if not l: tb.bomb('unexpected eof from the testbed')
	if not l.endswith('\n'): tb.bomb('unterminated line from the testbed')
	l = l.rstrip('\n')
	debug('<< '+l)
	ll = l.split()
	if not ll: tb.bomb('unexpected whitespace-only line from the testbed')
	if ll[0] != keyword:
		if tb.lastsend is None:
			tb.bomb("got banner `%s', expected `%s...'" %
				(l, keyword))
		else:
			tb.bomb("sent `%s', got `%s', expected `%s...'" %
				(tb.lastsend, l, keyword))
	ll = ll[1:]
	if nresults is not None and len(ll) != nresults:
		tb.bomb("sent `%s', got `%s' (%d result parameters),"
			" expected %d result parameters" %
			(string, l, len(ll), nresults))
	return ll
 def commandr(tb, cmd, args=(), nresults=None):
	# pass args=[None,...] or =(None,...) to avoid more url quoting
	if type(cmd) is str: cmd = [cmd]
	if len(args) and args[0] is None: args = args[1:]
	else: args = map(urllib.quote, args)
	al = cmd + args
	tb.send(string.join(al))
	ll = tb.expect('ok', nresults)
	rl = map(urllib.unquote, ll)
	return rl
 def command(tb, cmd, args=()):
	tb.commandr(cmd, args, 0)
 def commandr1(tb, cmd, args=()):
	rl = tb.commandr(cmd, args, 1)
	return rl[0]
 def execute(tb, what, cmdargs,
		si='/dev/null', so='/dev/null', se=None, cwd=None,
		dump_fd=None):
	if cwd is None: cwd = tb.scratch.write(True)
	se_use = se
	if se_use is None:
		se_af = TemporaryFile('xerr-'+what)
		se_use = se_af.write(True)
	cmdl = [None,
		','.join(map(urllib.quote, cmdargs)),
		si, so, se_use, cwd]
	if dump_fd is not None: cmdl += ['debug=%d-%d' % (dump_fd,2)]
	rc = tb.commandr1('execute', cmdl)
	try: rc = int(rc)
	except ValueError: bomb("execute for %s gave invalid response `%s'"
					% (what,rc))
	if se is not None: return rc
	return (rc, file(se_af.read()).read())

#---------- representation of test control files: Field*, Test, etc.

class FieldBase:
 def __init__(f, fname, stz, base, tnames, vl):
	assert(vl)
	f.stz = stz
	f.base = base
	f.tnames = tnames
	f.vl = vl
 def words(f):
	def distribute(vle):
		(lno, v) = vle
		r = v.split()
		r = map((lambda w: (lno, w)), r)
		return r
	return flatten(map(distribute, f.vl))
 def atmostone(f):
	if len(vl) == 1:
		(f.lno, f.v) = vl[0]
	else:
		raise Unsupported(f.vl[1][0],
			'only one %s field allowed' % fn)
	return f.v

class FieldIgnore(FieldBase):
 def parse(f): pass

class Restriction:
 def __init__(r,rname,base): pass

class Restriction_rw_build_tree(Restriction): pass
class Restriction_rw_tests_tree(Restriction): pass
class Restriction_breaks_testbed(Restriction):
 def __init__(r, rname, base):
	if 'revert' not in testbed.caps:
		raise Unsupported(f.lno,
			'Test breaks testbed but testbed cannot revert')

class Field_Restrictions(FieldBase):
 def parse(f):
	for wle in f.words():
		(lno, rname) = wle
		rname = rname.replace('-','_')
		try: rclass = globals()['Restriction_'+rname]
		except KeyError: raise Unsupported(lno,
			'unknown restriction %s' % rname)
		r = rclass(rname, f.base)
		f.base['restrictions'].append(r)

class Field_Tests(FieldIgnore): pass

class Field_Depends(FieldBase):
 def parse(f):
	dl = map(lambda x: x.strip(),
		flatten(map(lambda x: x.split(','), f.vl)))
	re = regexp.compile('[^-.+:~]')
	for d in dl:
		if re.search(d):
			badpkg("Test Depends field contains dependency"
			       " `%s' with invalid characters" % d)
	f.base['depends'] = dl

class Field_Tests_directory(FieldBase):
 def parse(f):
	td = atmostone(f)
	if td.startswith('/'): raise Unspported(f.lno,
		'Tests-Directory may not be absolute')
	f.base['testsdir'] = td

def run_tests(stanzas, tree):
	global errorcode, testbed
	for stanza in stanzas:
		tests = stanza[' tests']
		if not tests:
			report('*', 'SKIP no tests in this package')
			errorcode |= 8
		for t in tests:
			t.prepare()
			t.run(tree)
			if 'breaks-testbed' in t.restrictions:
				testbed.needs_reset()
		testbed.needs_reset()

class Test:
 def __init__(t, tname, base, act):
	if '/' in tname: raise Unsupported(base[' lno'],
		'test name may not contain / character')
	for k in base: setattr(t,k,base[k])
	t.tname = tname
	t.act = act
	t.what = act.what+'t-'+tname
	if len(base['testsdir']): t.path = base['testsdir'] + '/' + tname
	else: t.path = tname
	t._debug('constructed; path=%s' % t.path)
	t._debug(' .depends=%s' % t.depends)
 def _debug(t, m):
	debug('& %s: %s' % (t.what, m))
 def report(t, m):
	report(t.what, m)
 def reportfail(t, m):
	global errorcode
	errorcode |= 4
	report(t.what, 'FAIL ' + m)
 def prepare(t):
	t._debug('preparing')
	dn = []
	for d in t.depends:
		t._debug(' processing dependency '+d)
		if not '*' in d:
			t._debug('  literal dependency '+d)
			dn.append(d)
		else:
			for (pkg,bin) in t.act.binaries:
				d = d.replace('*',pkg)
				t._debug('  synthesised dependency '+d)
				dn.append(d)
	testbed.prepare(dn)
 def run(t, tree):
	t._debug('running')
	def stdouterr(oe):
		idstr = t.what + '-' + oe
		if opts.output_dir is not None and opts.output_dir.tb:
			use_dir = opts.output_dir
		else:
			use_dir = testbed.scratch
		return RelativeOutputFile(idstr, use_dir, idstr)

	t.act.work.write(True)

	af = RelativeInputFile(t.what, tree, t.path)
	so = stdouterr('stdout')
	se = stdouterr('stderr')
	rc = testbed.execute('test-'+t.what,
		[opts.user_wrap(af.read(True))],
		so=so.write(True), se=se.write(True), cwd=tree.read(True))
			
	stab = os.stat(se.read())
	if stab.st_size != 0:
		l = file(se.read()).readline()
		l = l.rstrip('\n \t\r')
		if len(l) > 40: l = l[:40] + '...'
		t.reportfail('status: %d, stderr: %s' % (rc, l))
	elif rc != 0:
		t.reportfail('non-zero exit status %d' % rc)
	else:
		t.report('PASS')

def read_control(act, tree, control_override):
	stanzas = [ ]

	if control_override is not None:
		control_af = control_override
		testbed.blame('arg:'+control_override.spec)
	else:
		control_af = RelativeInputFile(act.what+'-testcontrol',
			tree, 'debian/tests/control')
	try:
		control = file(control_af.read(), 'r')
	except OSError, oe:
		if oe[0] != errno.ENOENT: raise
		return []

	lno = 0
	def badctrl(m): act.bomb('tests/control line %d: %s' % (lno, m))
	stz = None	# stz[field_name][index] = (lno, value)
			# special field names:
			# stz[' lno'] = number
			# stz[' tests'] = list of Test objects
	def end_stanza(stz):
		if stz is None: return
		stz[' errs'] = 0
		stanzas.append(stz)
		stz = None
		hcurrent = None

	initre = regexp.compile('([A-Z][-0-9a-z]*)\s*\:\s*(.*)$')
	while 1:
		l = control.readline()
		if not l: break
		lno += 1
		if not l.endswith('\n'): badctrl('unterminated line')
		if regexp.compile('\s*\#').match(l): continue
		if not regexp.compile('\S').match(l): end_stanza(stz); continue
		initmat = initre.match(l)
		if initmat:
			(fname, l) = initmat.groups()
			fname = string.capwords(fname)
			if stz is None:
				stz = { ' lno': lno, ' tests': [] }
			if not stz.has_key(fname): stz[fname] = [ ]
			hcurrent = stz[fname]
		elif regexp.compile('\s').match(l):
			if not hcurrent: badctrl('unexpected continuation')
		else:
			badctrl('syntax error')
		hcurrent.append((lno, l))
	end_stanza(stz)

	def testbadctrl(stz, lno, m):
		report_badctrl(lno, m)
		stz[' errs'] += 1

	for stz in stanzas:
		try:
			try: tnames = stz['Tests']
			except KeyError:
				tnames = ['*']
				raise Unsupported(stz[' lno'],
					'no Tests field')
			tnames = map((lambda lt: lt[1]), tnames)
			tnames = string.join(tnames).split()
			base = {
				'restrictions': [],
				'testsdir': 'debian/tests',
				'depends' : '*'
			}
			for fname in stz.keys():
				if fname.startswith(' '): continue
				vl = stz[fname]
				try: fclass = globals()['Field_'+
					fname.replace('-','_')]
				except KeyError: raise Unsupported(vl[0][0],
					'unknown metadata field %s' % fname)
				f = fclass(stz, fname, base, tnames, vl)
				f.parse()
			for tname in tnames:
				t = Test(tname, base, act)
				stz[' tests'].append(t)
		except Unsupported, u:
			for tname in tnames: u.report(tname)
			continue

	return stanzas

def print_exception(ei, msgprefix=''):
	if msgprefix: print >>sys.stderr, msgprefix
	(et, q, tb) = ei
	if et is Quit:
		print >>sys.stderr, 'adt-run:', q.m
		return q.ec
	else:
		print >>sys.stderr, "adt-run: unexpected, exceptional, error:"
		traceback.print_exc()
		return 20

def cleanup():
	try:
		rm_ec = 0
		if opts.tmpdir is None and tmpdir is not None:
			rmtree('tmpdir', tmpdir)
		if testbed is not None:
			testbed.reset_apt()
			testbed.stop()
		if rm_ec: bomb('rm -rf -- %s failed, code %d' % (tmpdir, ec))
	except:
		print_exception(sys.exc_info(),
			'\nadt-run: error cleaning up:\n')
		os._exit(20)

#---------- registration, installation etc. of .deb's: Binaries

def determine_package(act):
	cmd = 'dpkg-deb --info --'.split(' ')+[act.af.read(),'control']
	running = subprocess.Popen(cmd, stdout=subprocess.PIPE)
	output = running.communicate()[0]
	rc = running.wait()
	if rc: badpkg('failed to parse binary package, code %d' % rc)
	re = regexp.compile('^\s*Package\s*:\s*([0-9a-z][-+.0-9a-z]*)\s*$')
	act.pkg = None
	for l in output.split('\n'):
		m = re.match(l)
		if not m: continue
		if act.pkg: badpkg('two Package: lines in control file')
		act.pkg = m.groups()[0]
	if not act.pkg: badpkg('no good Package: line in control file')

class Binaries:
 def __init__(b):
	b.dir = TemporaryDir('binaries')
	b.dir.write()
	ok = False

	if opts.gnupghome is None:
		opts.gnupghome = tmpdir+'/gnupg'

	b._debug('initialising')
	try:
		for x in ['pubring','secring']:
			os.stat(opts.gnupghome + '/' + x + '.gpg')
		ok = True
	except OSError, oe:
		if oe.errno != errno.ENOENT: raise

	if ok: b._debug('no key generation needed')
	else: b.genkey()

 def _debug(b, s):
	debug('* '+s)

 def genkey(b):
	b._debug('preparing for key generation')

	mkdir_okexist(os.path.dirname(opts.gnupghome), 02755)
	mkdir_okexist(opts.gnupghome, 0700)

	script = '''
  cd "$1"
  exec >key-gen-log 2>&1
  cat <<"END" >key-gen-params
Key-Type: DSA
Key-Length: 1024
Key-Usage: sign
Name-Real: autopkgtest per-run key
Name-Comment: do not trust this key
Name-Email: autopkgtest@example.com
END
  set -x
  gpg --homedir="$1" --batch --gen-key key-gen-params
		'''
	cmdl = ['sh','-ec',script,'x',opts.gnupghome]
	debug_subprocess('genkey', cmdl, script=script)
	rc = subprocess.call(cmdl)
	if rc:
		try:
			f = open(opts.gnupghome+'/key-gen-log')
			tp = file.read()
		except OSError, e: tp = e
		print >>sys.stderr, tp
		bomb('key generation failed, code %d' % rc)

 def apt_configs(b):
	return {
		"Dir::Etc::sourcelist": b.dir.read(True)+'sources.list',
	}

 def apt_pkg_gdebi_script(b, arg, middle):
	script = [
		'import apt_pkg',
		'import urllib',
		'arg = urllib.unquote("%s")' % urllib.quote(arg),
		]
	for (k,v) in b.apt_configs().iteritems():
		v = urllib.quote(v)
		script.append('apt_pkg.Config.Set("%s",urllib.unquote("%s"))'
				% (k, v))
	script += [
		'from GDebi.Cache import Cache',
		'cache = Cache()',
		]
	for m in middle:
		script += m + [
		'print res',
		'print d.missingDeps',
		'print d.requiredChanges',
		'assert(res)',
		'cache.commit()',
		''
		]
	return '\n'.join(script)
 def apt_get(b):
	ag = ['apt-get','-qy']
	for kv in b.apt_configs().iteritems():
		ag += ['-o', '%s=%s' % kv]
	return ag

 def reset(b):
	b._debug('reset')
	rmtree('binaries', b.dir.read())
	b.dir.invalidate()
	b.dir.write()
	b.install = []
	b.blamed = []
	b.registered = set()

 def register(b, act, pkg, af, forwhat, blamed):
	b._debug('register what=%s deb_%s=%s pkg=%s af=%s'
		% (act.what, forwhat, act.ah['deb_'+forwhat], pkg, str(af)))

	if act.ah['deb_'+forwhat] == 'ignore': return

	b.blamed += testbed.blamed

	leafname = pkg+'.deb'
	dest = RelativeOutputFile('binaries--'+leafname, b.dir, leafname)

	try: os.remove(dest.write())
	except OSError, oe:
		if oe.errno != errno.ENOENT: raise e

	try: os.link(af.read(), dest.write())
	except OSError, oe:
		if oe.errno != errno.EXDEV: raise e
		shutil.copy(af.read(), dest)

	if act.ah['deb_'+forwhat] == 'install':
		b.install.append(pkg)

	b.registered.add(pkg)

 def publish(b):
	b._debug('publish')

	script = '''
  cd "$1"
  apt-ftparchive packages . >Packages
  gzip <Packages >Packages.gz
  apt-ftparchive release . >Release
  rm -f Release.gpg
  gpg --homedir="$2" --batch --detach-sign --armour -o Release.gpg Release
  gpg --homedir="$2" --batch --export >archive-key.pgp
		'''
	cmdl = ['sh','-ec',script,'x',b.dir.write(),opts.gnupghome]
	debug_subprocess('ftparchive', cmdl, script)
	rc = subprocess.call(cmdl)
	if rc: bomb('apt-ftparchive or signature failed, code %d' % rc)

	b.dir.invalidate(True)
	apt_source = b.dir.read(True)

	so = TemporaryFile('vlds')
	script = '''
  apt-key add archive-key.pgp >&2
  echo "deb file://'''+apt_source+''' /" >sources.list
  cat /etc/apt/sources.list >>sources.list
  if [ "x`ls /var/lib/dpkg/updates`" != x ]; then
    echo >&2 "/var/lib/dpkg/updates contains some files, aargh"; exit 1
  fi
  '''+ ' '.join(b.apt_get()) +''' update >&2
  cat /var/lib/dpkg/status
		'''
	testbed.mungeing_apt()
	debug_subprocess('apt-key', script=script)
	(rc,se) = testbed.execute('apt-key',
				['sh','-ec',script],
				so=so.write(True), cwd=b.dir.write(True))
	if rc: bomb('apt setup failed with exit code %d' % rc, se)

	testbed.blamed += b.blamed

	b._debug('publish reinstall checking...')
	pkgs_reinstall = set()
	pkg = None
	for l in file(so.read()):
		if l.startswith('Package: '):
			pkg = l[9:].rstrip()
		elif l.startswith('Status: install '):
			if pkg in b.registered:
				pkgs_reinstall.add(pkg)
				b._debug(' publish reinstall needs '+pkg)

	if pkgs_reinstall:
		for pkg in pkgs_reinstall: testbed.blame(pkg)
		what = 'apt-get-reinstall'
		cmdl = (b.apt_get() + ['--reinstall','install'] +
			[pkg for pkg in pkgs_reinstall])
		debug_subprocess(what, cmdl)
		(rc,se) = testbed.execute(what, cmdl)
		if rc: badpkg("installation of basic binarries failed,"
				" exit code %d" % rc, se)

	b._debug('publish install...')
	for pkg in b.install:
		what = 'apt-get-install-%s' % pkg
		testbed.blame(pkg)
		cmdl = b.apt_get() + ['install',pkg]
		debug_subprocess(what, cmdl)
		(rc,se) = testbed.execute(what, cmdl)
		if rc: badpkg("installation of %s failed, exit code %d"
				% (pkg, rc), se)

	b._debug('publish done')

#---------- processing of sources (building)

def source_rules_command(act,script,what,which,work,results_lines=0):
	if opts.debug:
		trace = "%s-%s-trace" % (what,which)
		script = [	"mkfifo -m600 "+trace,
				"tee <"+trace+" /dev/stderr >&4 &",
				"exec >"+trace+" 2>&1"	] + script

	script = [	"exec 3>&1 >&2",
			"set -x"	] + script
	script = '\n'.join(script)
	so = TemporaryFile('%s-%s-results' % (what,which))
	se = TemporaryFile('%s-%s-log' % (what,which))
	debug_subprocess('source-rules-command/%s/%s' % (act.what, which),
			script=script)
	rc = testbed.execute('%s-%s' % (what,which),
			['sh','-xec',script],
			so=so.write(True), se=se.write(True),
			cwd= work.write(True), dump_fd=4)
	results = file(so.read()).read().rstrip('\n').split("\n")
	se = file(se.read()).read()
	if rc: badpkg("%s failed with exit code %d" % (which,rc), se)
	if results_lines is not None and len(results) != results_lines:
		badpkg("got %d lines of results from %s where %d expected"
			% (len(results), which, results_lines), se)
	if results_lines==1: return results[0]
	return results

def build_source(act):
	act.blame = 'arg:'+act.af.spec
	testbed.blame(act.blame)
	testbed.needs_reset()

	what = act.what
	dsc = act.af
	basename = dsc.spec

	dsc_file = open(dsc.read())
	in_files = False
	fre = regexp.compile('^\s+[0-9a-f]+\s+\d+\s+([^/.][^/]*)$')
	for l in dsc_file:
		l = l.rstrip('\n')
		if l.startswith('Files:'): in_files = True; continue
		elif l.startswith('#'): pass
		elif not l.startswith(' '):
			in_files = False
			if l.startswith('Source:'):
				act.blame = 'dsc:'+l[7:].strip()
				testbed.blame(act.blame)
		if not in_files: continue

		m = fre.match(l)
		if not m: badpkg(".dsc contains unparseable line"
				" in Files: `%s'" % l)
		leaf = m.groups(0)[0]
		subfile = RelativeInputFile(what+'/'+leaf, dsc, leaf,
				sibling=True)
		subfile.read(True)
	dsc.read(True)

	script = binaries.apt_pkg_gdebi_script(
		dsc.read(True), [[
		'from GDebi.DscSrcPackage import DscSrcPackage',
		'd = DscSrcPackage(cache, arg)',
		'res = d.checkDeb()',
		 ],[
		'from GDebi.DebPackage import DebPackage',
		'd = DebPackage(cache)',
		'res = d.satisfyDependsStr("build-essential")',
		]])
	cmdl = ['python','-c',script]
	whatp = what+'-builddeps'
	debug_subprocess(whatp, cmdl, script=script)
	(rc,se) = testbed.execute(what, cmdl)
	if rc: badpkg('build-depends install failed, exit code %d' % rc, se)

	work = TemporaryDir(what+'-build')

	script = [
			'cd '+work.write(True),
		]
	if opts.user: script += [
			'chown '+opts.user+' .',
			'dsc=dsc.read(True) '+
				opts.user_wrap('dpkg-source -x $dsc')
		]
	else: script += [
			'dpkg-source -x '+dsc.read(True),
		]
	script += [
			'cd */.',
			'dpkg-checkbuilddeps',
			'pwd >&3',
			opts.user_wrap('debian/rules build'),
		]
	result_pwd = source_rules_command(act,script,what,'build',work,1)

	if os.path.dirname(result_pwd)+'/' != work.read(True):
		badpkg("results dir `%s' is not in expected parent dir `%s'"
			% (result_pwd, work.read(True)))

	act.work = work
	act.tests_tree = InputDir(what+'-tests-tree',
				work.read(True)+os.path.basename(result_pwd),
				True)
	if act.ah['dsc_tests']:
		act.tests_tree.read()
		testbed.register_ephemeral(act.work)
		testbed.register_ephemeral(act.tests_tree)

	act.blamed = copy.copy(testbed.blamed)

	def debug_b(m): debug('* <dsc:%s> %s' % (act.what, m))
	act.binaries = []
	filter = act.ah['dsc_filter']
	debug_b('filter=%s' % filter)
	if filter != '_':
		script = [
			'cd '+work.write(True)+'/*/.',
			opts.user_wrap(opts.gainroot+' debian/rules binary'),
			'cd ..',
			'echo *.deb >&3',
			]
		result_debs = source_rules_command(act,script,what,
				'binary',work,1)
		if result_debs == '*': debs = []
		else: debs = result_debs.split(' ')
		debug_b('debs='+`debs`)
		re = regexp.compile('^([-+.0-9a-z]+)_[^_/]+(?:_[^_/]+)\.deb$')
		for deb in debs:
			m = re.match(deb)
			if not m: badpkg("badly-named binary `%s'" % deb)
			pkg = m.groups()[0]
			debug_b(' deb=%s, pkg=%s' % (deb,pkg))
			for pat in filter.split(','):
				debug_b('  pat=%s' % pat)
				if not fnmatch.fnmatchcase(pkg,pat):
					debug_b('   no match')
					continue
				deb_what = pkg+'_'+what+'.deb'
				bin = RelativeInputFile(deb_what,work,deb,True)
				debug_b('  deb_what=%s, bin=%s' %
					(deb_what, str(bin)))
				binaries.register(act,pkg,bin,
					'forbuilds',testbed.blamed)
				act.binaries.append((pkg,bin))
				break
		debug_b('all done.')

#---------- main processing loop and main program

def process_actions():
	global binaries

	def debug_a1(m): debug('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ '+m)
	def debug_a2(m): debug('@@@@@@@@@@@@@@@@@@@@ '+m)
	def debug_a3(m): debug('@@@@@@@@@@ '+m)

	debug_a1('starting')
	testbed.open()
	binaries = Binaries()

	binaries.reset()

	debug_a1('builds ...')
	for act in opts.actions:
		debug_a2('%s %s' %
			(act.kind, act.what))

		testbed.prepare([])
		if act.kind == 'deb':
			testbed.blame('arg:'+act.af.spec)
			determine_package(act)
			testbed.blame('deb:'+act.pkg)
			binaries.register(act,act.pkg,act.af,
				'forbuilds',testbed.blamed)
		if act.kind == 'dsc':
			build_source(act)
		if act.kind == 'tree':
			act.binaries = []

	debug_a1('builds done.')

	binaries.reset()
	control_override = None

	debug_a1('tests ...')
	for act in opts.actions:
		debug_a2('test %s %s' % (act.kind, act.what))

		testbed.needs_reset()
		if act.kind == 'control':
			control_override = act.af
		if act.kind == 'deb':
			binaries.register(act,act.pkg,act.af,'fortests',
				['deb:'+act.pkg])
		if act.kind == 'dsc':
			for (pkg,bin) in act.binaries:
				binaries.register(act,pkg,bin,'fortests',
					act.blamed)
			if act.ah['dsc_tests']:
				debug_a3('read control ...')
				stanzas = read_control(act, act.tests_tree,
						control_override)
				testbed.blamed += act.blamed
				debug_a3('run_tests ...')
				run_tests(stanzas, act.tests_tree)
			control_override = None
		if act.kind == 'tree':
			testbed.blame('arg:'+act.af.spec)
			stanzas = read_control(act, act.af, control_override)
			debug_a3('run_tests ...')
			run_tests(stanzas, act.af)
			control_override = None
	debug_a1('tests done.')

def main():
	global testbed
	global tmpdir
	try:
		parse_args()
	except SystemExit, se:
		os._exit(20)
	try:
		testbed = Testbed()
		testbed.start()
		finalise_options()
		process_actions()
	except:
		ec = print_exception(sys.exc_info(), '')
		cleanup()
		os._exit(ec)
	cleanup()
	os._exit(errorcode)

main()
