#!/usr/bin/python2.4
#
# adt-run is part of autopkgtest
# autopkgtest is a tool for testing Debian binary packages
#
# autopkgtest is Copyright (C) 2006-2007 Canonical Ltd.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# See the file CREDITS for a full list of credits information (often
# installed as /usr/share/doc/autopkgtest/CREDITS).

import signal
import optparse
import tempfile
import sys
import subprocess
import traceback
import urllib
import string
import re as regexp
import os
import errno
import fnmatch
import shutil
import copy

from optparse import OptionParser
signal.signal(signal.SIGINT, signal.SIG_DFL) # undo stupid Python SIGINT thing

#---------- global variables

tmpdir = None		# pathstring on host
testbed = None		# Testbed
errorcode = 0		# exit status that we are going to use
binaries = None		# Binaries (.debs we have registered)

#---------- output handling
#
#  There are at least the following kinds of output:
#
#   1. stderr output which consists of
#   1a. our errors
#   1b. stuff printed to stderr by the virtualisation server
#   1c. stuff printed to stderr by our short-lived subprocesseses
#           which we don't expect to fail
#
#   2. trace information, which consists of
#   2a. our trace information from calls to debug()
#   2b. progress information and stderr output from
#        general scripts we run on the host
#   2c. progress information and stderr output from things
#        we run on the testbed including builds
#   2d. stderr and stdout output from actual tests
#
#   xxxx
#   3. actual test results (printed to our stdout)
#
# Cloning of 1a and 2a, where necessary, is done by us writing
# the data twice.  Cloning of 1[bc] and 2[bc], where necessary,
# is done by forking off a copy of ourselves to do plumbing,
# which copy we wait for at the appropriate point.

trace_stream = None

def pstderr(m):
	print >>sys.stderr, m
	if trace_stream is not None: print >>trace_stream, m

def debug(m, minlevel=0):
	if opts.debuglevel < minlevel: return
	if opts.quiet and trace_stream is None: return
	p = 'adt-run: debug'
	if minlevel: p += `minlevel`
	p += ': '
	for l in m.rstrip('\n').split('\n'):
		s = p + l
		if not opts.quiet: print >>sys.stderr, s
		if trace_stream is not None: print >>trace_stream, s

def debug_file(hp, minlevel=0):
	if opts.debuglevel < minlevel: return
	def do_copy(stream, what):
		rc = subprocess.call(['cat',hp], stdout=stream)
		if rc: bomb('cat failed copying data from %s'
			    ' to %s, exit code %d' % (hp, what, rc))
	if not opts.quiet: do_copy(sys.stderr, 'stderr')
	if trace_stream is not None: do_copy(trace_stream, 'trace log')

class Errplumb:
 def __init__(ep, critical=False):
	to_stderr = critical or not opts.quiet
	count = to_stderr + (trace_stream is not None)
	if count == 0:
		ep.stream = open('/dev/null','w')
		ep._sp = None
	elif count == 1:
		if to_stderr: ep.stream = sys.stderr
		else: ep.stream = trace_stream
		ep._sp = None
	else:
		ep._sp = subprocess.Popen(['tee','/dev/stderr'],
			stdin=subprocess.PIPE, stdout=trace_stream,
			close_fds=True)
		ep.stream = ep._sp.stdin
 def wait(ep):
	if ep._sp is None: return
	ep._sp.stdin.close()
	rc = ep._sp.wait()
	if rc: bomb('stderr plumbing tee(1) failed, exit code %d' % rc)
	ep._sp = None

def subprocess_cooked(cmdl, critical=False, dbg=None, **kwargs):
	if dbg is not None:
		if isinstance(dbg,tuple): (what,script) = dbg
		else: (what,script) = (dbg,None)
		debug_subprocess(what, cmdl, script=script)
	ep = Errplumb(critical)
	running = subprocess.Popen(cmdl, stderr=ep.stream, **kwargs)
	output = running.communicate()[0]
	rc = running.wait()
	ep.wait()
	return (rc, output)

def preport(m):
	print m
	if trace_stream is not None: print >>trace_stream, m

def report(tname, result):
	preport('%-20s %s' % (tname, result))

#---------- errors we define

class Quit:
	def __init__(q,ec,m): q.ec = ec; q.m = m

def bomb(m):
	raise Quit(20, "unexpected error: %s" % m)

def badpkg(m):
	preport('blame: ' + ' '.join(testbed.blamed))
	preport('badpkg: ' + m)
	raise Quit(12, "erroneous package: %s" % m)

class Unsupported:
 def __init__(u, lno, m):
	if lno >= 0: u.m = '%s (control line %d)' % (m, lno)
	else: u.m = m
 def report(u, tname):
	global errorcode
	errorcode != 2
	report(tname, 'SKIP %s' % u.m)

#---------- convenience function

def mkdir_okexist(pathname, mode=02755):
	try:
		os.mkdir(pathname, mode)
	except OSError, oe:
		if oe.errno != errno.EEXIST: raise

def rmtree(what, pathname):
	debug('/ %s rmtree %s' % (what, pathname), 2)
	shutil.rmtree(pathname)

def debug_subprocess(what, cmdl=None, script=None):
	o = '$ '+what+':'
	if cmdl is not None:
		ol = []
		for x in cmdl:
			if x is script: x = '<SCRIPT>'
			ol.append(x.	replace('\\','\\\\').
					replace(' ','\\ ')	)
		o += ' '+ ' '.join(ol)
	debug(o)
	if script is not None and opts.debuglevel >= 1:
		o = ''
		for l in script.rstrip('\n').split('\n'):
			o += '$     '+l+'\n'
		debug(o,1)

def flatten(l):
	return reduce((lambda a,b: a + b), l, []) 

#---------- fancy automatic file-copying class

class AutoFile:
	# p.what
	# p.path[tb]	None or path	not None => path known
	# p.file[tb]	None or path	not None => file exists
	# p.spec	string or None
	# p.spec_tbp	True or False, or not set if spec is None
	# p.dir		'' or '/'

 def __init__(p, what):
	p.what = what
	p.path = [None,None]
	p.file = [None,None]
	p.spec = None
	p.dir = ''

 def __repr__(p):
	return "<AF@%s>" % p.__str__()
 def __str__(p):
	def ptbp(tbp):
		if p.path[tbp] is None: return '-'+p.dir
		elif p.file[tbp] is None: return p.path[tbp]+p.dir+'?'
		else: return p.path[tbp]+p.dir+'!'
	out = p.what
	if p.spec is not None:
		if p.spec_tbp: out += '#'
		else: out += '='
		out += p.spec
	out += ':'
	out += ptbp(False)
	out += '|'
	out += ptbp(True)
	return out

 def _wrong(p, how):
	xtra = ''
	if p.spec is not None: xtra = ' spec[%s]=%s' % (p.spec, p.spec_tb)
	raise ("internal error: %s (%s)" % (how, str(p)))

 def _ensure_path(p, tbp):
	if p.path[tbp] is None:
		if '/' in p.what:
			p._debug('tmp-parent %s...' % 'HT'[tbp])
			TemporaryDir(os.path.dirname(p.what)).write(tbp)
		if not tbp:
			p.path[tbp] = tmpdir+'/'+p.what
		else:
			p.path[tbp] = testbed.scratch.path[True]+'/'+p.what

 def write(p, tbp=False):
	p._debug('write %s...' % 'HT'[tbp])
	p._ensure_path(tbp)

	if p.dir and not p.file[tbp]:
		if not tbp:
			p._debug('mkdir H')
			mkdir_okexist(p.path[tbp])
		else:
			cmdl = ['sh','-ec',
				'test -d "$1" || mkdir -p "$1"',
				'x', p.path[tbp]]
			tf_what = urllib.quote(p.what).replace('/','%2F')
			rc = testbed.execute('mkdir-'+tf_what, cmdl)
			if rc: bomb('failed to create directory %s' %
				p.path[tbp])

	p.file[tbp] = p.path[tbp]
	return p.path[tbp]

 def read(p, tbp=False):
	p._debug('read %s...' % 'HT'[tbp])
	p._ensure_path(tbp)

	if p.file[tbp] is None:
		if p.file[not tbp] is None:
			p._wrong("requesting read but nonexistent")
		cud = ['copyup','copydown'][tbp]
		src = p.file[not tbp] + p.dir
		dst = p.path[tbp] + p.dir
		testbed.command(cud, (src, dst))
		p.file[tbp] = p.path[tbp]

	return p.file[tbp] + p.dir

 def invalidate(p, tbp=False):
	p.file[tbp] = None
	p._debug('invalidated %s' % 'HT'[tbp])

 def _debug(p, m):
	debug('/ %s#%x: %s' % (p.what, id(p), m), 3)

 def _constructed(p):
	p._debug('constructed: '+str(p))
	p._check()

 def _check(p):
	for tbp in [False,True]:
	 for pf in [p.path, p.file]:
		if pf[tbp] is None: continue
		if not pf[tbp]: bomb('empty path specified for %s' % p.what)
		if p.dir and pf[tbp].endswith('/'):
			pf[tbp] = pf[tbp].rstrip('/')
			if not pf[tbp]: pf[tbp] = '/'
		if not p.dir and pf[tbp].endswith('/'):
			bomb("directory `%s' specified for "
			     "non-directory %s" % (pf[tbp], p.what))

 def _relative_init(p, what, parent, leaf, onlyon_tbp, setfiles, sibling):
	AutoFile.__init__(p,what)
	sh_on = ''; sh_sibl = ''
	if onlyon_tbp is not None: sh_on = ' (on %s)' % ('HT'[onlyon_tbp])
	if sibling: sh_sibl=' (sibling)'
	parent._debug('using as base: %s: %s%s%s' %
			(str(parent), leaf, sh_on, sh_sibl))
	if not sibling and not parent.dir:
		parent._wrong('asked for non-sibling relative path of non-dir')
	if sibling: trim = os.path.dirname
	else: trim = lambda x: x
	for tbp in [False,True]:
		if parent.path[tbp] is None: continue
		trimmed = trim(parent.path[tbp])
		if trimmed: trimmed += '/'
		p.path[tbp] = trimmed + leaf
		if setfiles and (onlyon_tbp is None or onlyon_tbp == tbp):
			p.file[tbp] = p.path[tbp]

class InputFile(AutoFile):
 def _init(p, what, spec, spec_tbp=False):
	AutoFile.__init__(p, what)
	p.spec = spec
	p.spec_tbp = spec_tbp
	p.path[spec_tbp] = spec
	p.file[p.spec_tbp] = p.path[p.spec_tbp]
 def __init__(p, what, spec, spec_tbp=False):
	p._init(what,spec,spec_tbp)
	p._constructed()

class InputDir(InputFile):
 def __init__(p, what, spec, spec_tbp=False):
	InputFile._init(p,what,spec,spec_tbp)
	p.dir = '/'
	p._constructed()

class OutputFile(AutoFile):
 def _init(p, what, spec, spec_tbp=False):
	AutoFile.__init__(p, what)
	p.spec = spec
	p.spec_tbp = spec_tbp
	p.path[spec_tbp] = spec
 def __init__(p, what, spec, spec_tbp=False):
	p._init(what,spec,spec_tbp)
	p._constructed()

class OutputDir(OutputFile):
 def __init__(p, what, spec, spec_tbp=False):
	OutputFile._init(p,what,spec,spec_tbp)
 	p.dir = '/'
	p._constructed()

class RelativeInputFile(AutoFile):
 def __init__(p, what, parent, leaf, onlyon_tbp=None, sibling=False):
	p._relative_init(what, parent, leaf, onlyon_tbp, True, sibling)
	p._constructed()

class RelativeOutputFile(AutoFile):
 def __init__(p, what, parent, leaf, sibling=False):
	p._relative_init(what, parent, leaf, None, False, sibling)
	p._constructed()

class TemporaryFile(AutoFile):
 def __init__(p, what):
	AutoFile.__init__(p, what)
	p._constructed()

class TemporaryDir(AutoFile):
 def __init__(p, what):
	AutoFile.__init__(p, what)
	p.dir = '/'
	p._constructed()

#---------- parsing and representation of the arguments

class Action:
 def __init__(a, kind, af, arghandling, what):
	# extra attributes get added during processing
	a.kind = kind
	a.af = af
	a.ah = arghandling
	a.what = what
 def __repr__(a):
	return "<Action %s %s %s>" % (a.kind, a.what, `a.af`)

def parse_args():
	global opts
	usage = "%prog <options> --- <virt-server>..."
	parser = OptionParser(usage=usage)
	pa = parser.add_option
	pe = parser.add_option

	arghandling = {
		'dsc_tests': True,
		'dsc_filter': '*',
		'deb_forbuilds': 'auto',
		'deb_fortests': 'auto',
		'tb': False,
		'override_control': None
	}
	initial_arghandling = arghandling.copy()
	n_non_actions = 0

	#----------
	# actions (ie, test sets to run, sources to build, binaries to use):

	def cb_action(op,optstr,value,parser, long,kindpath,is_act):
		parser.largs.append((value,kindpath))
		n_non_actions += not(is_act)

	def pa_action(long, metavar, kindpath, help, is_act=True):
		pa('','--'+long, action='callback', callback=cb_action,
			nargs=1, type='string',
			callback_args=(long,kindpath,is_act), help=help)

	pa_action('built-tree',		'TREE', '@/',
		help='run tests from build tree TREE')

	pa_action('unbuilt-tree',	'TREE', '@//',
		help='run tests from build tree TREE')

	pa_action('source',		'DSC', '@.dsc',
		help='build DSC and use its tests and/or'
		    ' generated binary packages')

	pa_action('binary',		'DEB', '@.deb',
	       help='use binary package DEB according'
		    ' to most recent --binaries-* settings')

	pa_action('override-control',	'CONTROL', ('control',), is_act=0,
	       help='run tests from control file CONTROL instead,'
		    ' (applies to next test suite only)')

	#----------
	# argument handling settings (what ways to use action
	#  arguments, and pathname processing):

	def cb_setah(option, opt_str, value, parser, toset,setval):
		if type(setval) == list:
			if not value in setval:
				parser.error('value for %s option (%s) is not '
				 'one of the permitted values (%s)' %
				 (value, opt_str, setval.join(' ')))
		elif setval is not None:
			value = setval
		for v in toset:
			arghandling[v] = value
		parser.largs.append(arghandling.copy())

	def pa_setah(long, affected,effect, metavar=None, **kwargs):
		type = metavar
		if type is not None: type = 'string'
		pa('',long, action='callback', callback=cb_setah,
		   callback_args=(affected,effect), **kwargs)

	#---- paths: host or testbed:
	#
	pa_setah('--paths-testbed', ['tb'],True,
		help='subsequent path specifications refer to the testbed')
	pa_setah('--paths-host', ['tb'],False,
		help='subsequent path specifications refer to the host')

	#---- source processing settings:

	pa_setah('--sources-tests', ['dsc_tests'],True,
		help='run tests from builds of subsequent sources')
	pa_setah('--sources-no-tests', ['dsc_tests'],False,
		help='do not run tests from builds of subsequent sources')

	pa_setah('--built-binaries-filter', ['dsc_filter'],None,
		type='string', metavar='PATTERN-LIST',
		help='from subsequent sources, use binaries matching'
		     ' PATTERN-LIST (comma-separated glob patterns)'
		     ' according to most recent --binaries-* settings')
	pa_setah('--no-built-binaries', ['dsc_filter'], '_',
		help='from subsequent sources, do not use any binaries')

	#---- binary package processing settings:

	def pa_setahbins(long,toset,how):
	 pa_setah(long, toset,['ignore','auto','install'],
		type='string', metavar='IGNORE|AUTO|INSTALL', default='auto',
		help=how+' ignore binaries, install them as needed'
			' for dependencies, or unconditionally install'
			' them, respectively')
	pa_setahbins('--binaries', ['deb_forbuilds','deb_fortests'], '')
	pa_setahbins('--binaries-forbuilds', ['deb_forbuilds'], 'for builds, ')
	pa_setahbins('--binaries-fortests', ['deb_fortests'], 'for tests, ')

	#----------
	# general options:

	def cb_vserv(op,optstr,value,parser):
		parser.values.vserver = list(parser.rargs)
		del parser.rargs[:]

	def cb_path(op,optstr,value,parser, constructor,long,dir):
		name = long.replace('-','_')
		af = constructor(arghandling['tb'], value, long, dir)
		setattr(parser.values, name, af)

	def pa_path(long, constructor, help, dir=False):
		pa('','--'+long, action='callback', callback=cb_path,
			callback_args=(constructor,long,dir),
			nargs=1, type='string',
			help=help, metavar='PATH')

	pa_path('output-dir', OutputDir, dir=True,
		help='write stderr/out files in PATH')

	pa('','--tmp-dir', 		type='string', dest='tmpdir',
		help='write temporary files to TMPDIR, emptying it'
		     ' beforehand and leaving it behind at the end')
	pa('','--log-file', 		type='string', dest='logfile',
		help='write the log LOGFILE, emptying it beforehand,'
		     ' instead of using OUTPUT-DIR/log or TMPDIR/log')

	pa('','--user',			type='string', dest='user',
		help='run tests as USER (needs root on testbed)')
	pa('','--gain-root',		type='string', dest='gainroot',
		help='prefix debian/rules binary with GAINROOT')
	pa('-q', '--quiet', action='store_false', dest='quiet', default=False);
	pa('-d', '--debug', action='count', dest='debuglevel', default=0);
	pa('','--gnupg-home',		type='string', dest='gnupghome',
		default='~/.autopkgtest/gpg',
		help='use GNUPGHOME rather than ~/.autopkgtest (for'
			" signing private apt archive);"
			" `fresh' means generate new key each time.")

	#----------
	# actual meat:

	class SpecialOption(optparse.Option): pass
	vs_op = SpecialOption('','--VSERVER-DUMMY')
	vs_op.action = 'callback'
	vs_op.type = None
	vs_op.default = None
	vs_op.nargs = 0
	vs_op.callback = cb_vserv
	vs_op.callback_args = ( )
	vs_op.callback_kwargs = { }
	vs_op.help = 'introduces virtualisation server and args'
	vs_op._short_opts = []
	vs_op._long_opts = ['---']

	pa(vs_op)

	(opts,args) = parser.parse_args()
	if not hasattr(opts,'vserver'):
		parser.error('you must specifiy --- <virt-server>...')
	if n_non_actions >= len(parser.largs):
		parser.error('nothing to do specified')

	arghandling = initial_arghandling
	opts.actions = []
	ix = 0
	for act in args:
		if type(act) == dict:
			arghandling = act
			continue
		elif type(act) == tuple:
			pass
		elif type(act) == str:
			act = (act,act)
		else:
			raise ("unknown action in list `%s' having"
			      " type `%s'" % (act, type(act)))
		(pathstr, kindpath) = act

		constructor = InputFile
		if type(kindpath) is tuple:		kind = kindpath[0]
		elif kindpath.endswith('.deb'):		kind = 'deb'
		elif kindpath.endswith('.dsc'):		kind = 'dsc'
		elif kindpath.endswith('//'):
			kind = 'ubtree'
			constructor = InputDir
		elif kindpath.endswith('/'):
			kind = 'tree'
			constructor = InputDir
		else: parser.error("do not know how to handle filename \`%s';"
			" specify --source --binary or --build-tree")

		what = '%s%s' % (kind,ix); ix += 1

		if kind == 'dsc': fwhatx = '/' + os.path.basename(pathstr)
		else: fwhatx = '-'+kind

		af = constructor(what+fwhatx, pathstr, arghandling['tb'])
		opts.actions.append(Action(kind, af, arghandling, what))

def setup_trace():
	global trace_stream, tmpdir

	if opts.tmpdir is not None:
		rmtree('tmpdir(specified)',opts.tmpdir)
		mkdir_okexist(opts.tmpdir, 0700)
		tmpdir = opts.tmpdir
	else:
		assert(tmpdir is None)
		tmpdir = tempfile.mkdtemp()

	if opts.logfile is None:
		if opts.output_dir is not None and opts.output_dir.spec_tbp:
			opts.logfile = opts.output_dir.spec + '/log'
		elif opts.tmpdir is not None:
			opts.logfile = opts.tmpdir + '/log'
	if opts.logfile is not None:
		trace_stream = open(opts.logfile, 'w', 0)

	debug('options: '+`opts`, 1)

def finalise_options():
	global opts, tb

	if opts.user is None and 'root-on-testbed' not in testbed.caps:
		opts.user = ''

	if opts.user is None:
		su = 'suggested-normal-user='
		ul = [
			e[len(su):]
			for e in testbed.caps
			if e.startswith(su)
			]
		if ul:
			opts.user = ul[0]
		else:
			opts.user = ''

	if opts.user:
		if 'root-on-testbed' not in testbed.caps:
			pstderr("warning: virtualisation"
				" system does not offer root on testbed,"
				" but --user option specified: failure likely")
		opts.user_wrap = lambda x: "su %s -c '%s'" % (opts.user, x)
	else:
		opts.user_wrap = lambda x: x

	if opts.gainroot is None:
		opts.gainroot = ''
		if (opts.user or
		    'root-on-testbed' not in testbed.caps):
			opts.gainroot = 'fakeroot'

	if opts.gnupghome.startswith('~/'):
		try: home = os.environ['HOME']
		except KeyError:
			parser.error("HOME environment variable"
				" not set, needed for --gnupghome=`%s"
				% opts.gnupghome)
		opts.gnupghome = home + opts.gnupghome[1:]
	elif opts.gnupghome == 'fresh':
		opts.gnupghome = None

#---------- testbed management - the Testbed class

class Testbed:
 def __init__(tb):
	tb.sp = None
	tb.lastsend = None
	tb.scratch = None
	tb.modified = False
	tb.blamed = []
	tb._ephemeral = []
	tb._debug('init')
	tb._need_reset_apt = False
 def _debug(tb, m, minlevel=0):
	debug('** '+m, minlevel)
 def start(tb):
	tb._debug('start')
	p = subprocess.PIPE
	debug_subprocess('vserver', opts.vserver)
	tb._errplumb = Errplumb(True)
	tb.sp = subprocess.Popen(opts.vserver,
		stdin=p, stdout=p, stderr=tb._errplumb.stream)
	tb.expect('ok')
	tb.caps = tb.commandr('capabilities')
 def stop(tb):
	tb._debug('stop')
	tb.close()
	if tb.sp is None: return
	ec = tb.sp.returncode
	if ec is None:
		tb.sp.stdout.close()
		tb.send('quit')
		tb.sp.stdin.close()
		ec = tb.sp.wait()
	if ec:
		tb.bomb('testbed gave exit status %d after quit' % ec)
	tb._errplumb.wait()
 def open(tb):
	tb._debug('open, scratch=%s' % tb.scratch)
	if tb.scratch is not None: return
	pl = tb.commandr('open')
	tb.scratch = InputDir('tb-scratch', pl[0], True)
	tb.deps_processed = []
 def mungeing_apt(tb):
	if not 'revert' in tb.caps:
		tb._need_reset_apt = True
 def reset_apt(tb):
	if not tb._need_reset_apt: return
	what = 'aptget-update-reset'
	cmdl = ['apt-get','-qy','update']
	rc = tb.execute(what, cmdl)
	if rc:
		pstderr("\n" "warning: failed to restore"
			" testbed apt cache, exit code %d" % rc)
	tb._need_reset_apt = False
 def close(tb):
	tb._debug('close, scratch=%s' % tb.scratch)
	if tb.scratch is None: return
	tb.scratch = None
	if tb.sp is None: return
	tb.command('close')
 def prepare(tb, deps_new):
	tb._debug('prepare, modified=%s, deps_processed=%s, deps_new=%s' %
		(tb.modified, tb.deps_processed, deps_new), 1)
	if 'revert' in tb.caps and (tb.modified or
	    [d for d in tb.deps_processed if d not in deps_new]):
		tb._debug('reset **')
		tb.command('revert')
		tb.blamed = []
		for af in tb._ephemeral: af.invalidate(True)
	binaries.publish()
	tb.modified = False
	tb._install_deps(deps_new)
 def register_ephemeral(tb, af):
	if not getattr(af,'spec_tbp',False): tb._ephemeral.append(af)
 def _install_deps(tb, deps_new):
	tb._debug(' installing dependencies '+`deps_new`, 1)
	tb.deps_processed = deps_new
	if not deps_new: return
	dstr = ', '.join(deps_new)
	script = binaries.apt_pkg_gdebi_script(
		dstr, [[
		'from GDebi.DebPackage import DebPackage',
		'd = DebPackage(cache)',
		'res = d.satisfyDependsStr(arg)',
		]])
	cmdl = ['python','-c',script]
	what = 'install-deps'
	rc = testbed.execute(what+'-debinstall', cmdl, script=script)
	if rc: badpkg('dependency install failed, exit code %d' % rc)
 def needs_reset(tb):
	tb._debug('needs_reset, previously=%s' % tb.modified, 1)
	tb.modified = True
 def blame(tb, m):
	tb._debug('blame += %s' % m, 1)
	tb.blamed.append(m)
 def bomb(tb, m):
	tb._debug('bomb %s' % m)
	if tb.sp is not None:
		tb.sp.stdout.close()
		tb.sp.stdin.close()
		ec = tb.sp.wait()
		if ec: pstderr('adt-run: testbed failing,'
				' exit status %d' % ec)
	tb.sp = None
	raise Quit(16, 'testbed failed: %s' % m)
 def send(tb, string):
	tb.sp.stdin
	try:
		debug('>> '+string, 2)
		print >>tb.sp.stdin, string
		tb.sp.stdin.flush()
		tb.lastsend = string
	except:
		(type, value, dummy) = sys.exc_info()
		tb.bomb('cannot send to testbed: %s' % traceback.
			format_exception_only(type, value))
 def expect(tb, keyword, nresults=None):
	l = tb.sp.stdout.readline()
	if not l: tb.bomb('unexpected eof from the testbed')
	if not l.endswith('\n'): tb.bomb('unterminated line from the testbed')
	l = l.rstrip('\n')
	debug('<< '+l, 2)
	ll = l.split()
	if not ll: tb.bomb('unexpected whitespace-only line from the testbed')
	if ll[0] != keyword:
		if tb.lastsend is None:
			tb.bomb("got banner `%s', expected `%s...'" %
				(l, keyword))
		else:
			tb.bomb("sent `%s', got `%s', expected `%s...'" %
				(tb.lastsend, l, keyword))
	ll = ll[1:]
	if nresults is not None and len(ll) != nresults:
		tb.bomb("sent `%s', got `%s' (%d result parameters),"
			" expected %d result parameters" %
			(string, l, len(ll), nresults))
	return ll
 def commandr(tb, cmd, args=(), nresults=None):
	# pass args=[None,...] or =(None,...) to avoid more url quoting
	if type(cmd) is str: cmd = [cmd]
	if len(args) and args[0] is None: args = args[1:]
	else: args = map(urllib.quote, args)
	al = cmd + args
	tb.send(string.join(al))
	ll = tb.expect('ok', nresults)
	rl = map(urllib.unquote, ll)
	return rl
 def command(tb, cmd, args=()):
	tb.commandr(cmd, args, 0)
 def commandr1(tb, cmd, args=()):
	rl = tb.commandr(cmd, args, 1)
	return rl[0]
 def execute(tb, what, cmdl,
		si='/dev/null', so='/dev/null', se=None, cwd=None,
		script=False):
	# Options for script:
	#   False - do not call debug_subprocess, no synch. reporting required
	#   None or string - call debug_subprocess with that value,
	#			plumb stderr through synchronously if possible
	# Options for se:
	#   None - usual Errplumb (output is of kind 2c)
	#   string - path on testbed (output is of kind 2d)

	if script is not False: debug_subprocess(what, cmdl, script=script)
	if cwd is None: cwd = tb.scratch.write(True)

	xdump = None
	if se is None:
		ep = Errplumb()
		se_catch = TemporaryFile(what+'-xerr')
		se_use = se_catch.write(True)
		if not opts.quiet: xdump = 'debug=2-2'
		elif trace_stream is not None:
			xdump = 'debug=2-%d' % trace_stream.fileno()
	else:
		ep = None
		se_catch = None
		se_use = se

	cmdl = [None,
		','.join(map(urllib.quote, cmdl)),
		si, so, se_use, cwd]
	if xdump is not None and 'execute-debug' in tb.caps: cmdl += [xdump]
	rc = tb.commandr1('execute', cmdl)
	try: rc = int(rc)
	except ValueError: bomb("execute for %s gave invalid response `%s'"
					% (what,rc))

	if se_catch is not None:
		debug_file(se_catch.read())
	if ep is not None:
		ep.wait()

	return rc

#---------- representation of test control files: Field*, Test, etc.

class FieldBase:
 def __init__(f, fname, stz, base, tnames, vl):
	assert(vl)
	f.stz = stz
	f.base = base
	f.tnames = tnames
	f.vl = vl
 def words(f):
	def distribute(vle):
		(lno, v) = vle
		r = v.split()
		r = map((lambda w: (lno, w)), r)
		return r
	return flatten(map(distribute, f.vl))
 def atmostone(f):
	if len(vl) == 1:
		(f.lno, f.v) = vl[0]
	else:
		raise Unsupported(f.vl[1][0],
			'only one %s field allowed' % fn)
	return f.v

class FieldIgnore(FieldBase):
 def parse(f): pass

class Restriction:
 def __init__(r,rname,base): pass

class Restriction_rw_build_tree(Restriction): pass
class Restriction_breaks_testbed(Restriction):
 def __init__(r, rname, base):
	if 'revert' not in testbed.caps:
		raise Unsupported(f.lno,
			'Test breaks testbed but testbed cannot revert')
class Restriction_needs_root(Restriction):
 def __init__(r, rname, base):
	if 'root-on-testbed' not in testbed.caps:
		raise Unsupported(f.lno,
			'Test needs root on testbed which is not available')

class Field_Restrictions(FieldBase):
 def parse(f):
	for wle in f.words():
		(lno, rname) = wle
		nrname = rname.replace('-','_')
		try: rclass = globals()['Restriction_'+nrname]
		except KeyError: raise Unsupported(lno,
			'unknown restriction %s' % rname)
		r = rclass(nrname, f.base)
		f.base['restrictions'].append(r)

class Field_Tests(FieldIgnore): pass
class Field_Features(FieldIgnore): pass

class Field_Depends(FieldBase):
 def parse(f):
	print >>sys.stderr, "Field_Depends:", `f.stz`, `f.base`, `f.tnames`, `f.vl`
	dl = map(lambda x: x.strip(),
		flatten(map(lambda (lno, v): v.split(','), f.vl)))
	re = regexp.compile('[^-.+:~0-9a-z()<>=*]')
	for d in dl:
		if re.search(d):
			badpkg("Test Depends field contains dependency"
			       " `%s' with invalid characters" % d)
	f.base['depends'] = dl

class Field_Tests_directory(FieldBase):
 def parse(f):
	td = atmostone(f)
	if td.startswith('/'): raise Unspported(f.lno,
		'Tests-Directory may not be absolute')
	f.base['testsdir'] = td

def run_tests(stanzas, tree):
	global errorcode, testbed
	for stanza in stanzas:
		tests = stanza[' tests']
		if not tests:
			report('*', 'SKIP no tests in this package')
			errorcode |= 8
		for t in tests:
			t.prepare()
			t.run(tree)
			if 'breaks-testbed' in t.restrictions:
				testbed.needs_reset()
		testbed.needs_reset()

class Test:
 def __init__(t, tname, base, act):
	if '/' in tname: raise Unsupported(base[' lno'],
		'test name may not contain / character')
	for k in base: setattr(t,k,base[k])
	t.tname = tname
	t.act = act
	t.what = act.what+'t-'+tname
	if len(base['testsdir']): t.path = base['testsdir'] + '/' + tname
	else: t.path = tname
	t._debug('constructed; path=%s' % t.path)
	t._debug(' .depends=%s' % t.depends)
 def _debug(t, m):
	debug('& %s: %s' % (t.what, m))
 def report(t, m):
	report(t.what, m)
 def reportfail(t, m):
	global errorcode
	errorcode |= 4
	report(t.what, 'FAIL ' + m)
 def prepare(t):
	t._debug('preparing')
	dn = []
	for d in t.depends:
		t._debug(' processing dependency '+d)
		if not '@' in d:
			t._debug('  literal dependency '+d)
			dn.append(d)
		else:
			for (pkg,bin) in t.act.binaries:
				d = d.replace('@',pkg)
				t._debug('  synthesised dependency '+d)
				dn.append(d)
	testbed.prepare(dn)
 def run(t, tree):
	t._debug('[----------------------------------------')
	def stdouterr(oe):
		idstr = t.what + '-' + oe
		if opts.output_dir is not None and opts.output_dir.tb:
			use_dir = opts.output_dir
		else:
			use_dir = testbed.scratch
		return RelativeOutputFile(idstr, use_dir, idstr)

	t.act.work.write(True)

	af = RelativeInputFile(t.what, tree, t.path)
	so = stdouterr('stdout')
	se = stdouterr('stderr')
	tf = af.read(True)
	if 'needs-root' not in t.restrictions:
		tf = opts.user_wrap(tf)
	rc = testbed.execute('test-'+t.what, [tf],
		so=so.write(True), se=se.write(True), cwd=tree.read(True))

	so_read = so.read()
	se_read = se.read()

	t._debug(' - - - - - - - - - - results - - - - - - - - - -')
	stab = os.stat(se_read)
	if stab.st_size != 0:
		l = open(se_read).readline()
		l = l.rstrip('\n \t\r')
		if len(l) > 40: l = l[:40] + '...'
		t.reportfail('status: %d, stderr: %s' % (rc, l))
		t._debug(' - - - - - - - - - - stderr - - - - - - - - - -')
		debug_file(se_read)
	elif rc != 0:
		t.reportfail('non-zero exit status %d' % rc)
	else:
		t.report('PASS')

	stab = os.stat(so_read)
	if stab.st_size != 0:
		t._debug(' - - - - - - - - - - stdout - - - - - - - - - -')
		debug_file(so_read)

	t._debug('----------------------------------------]')

def read_control(act, tree, control_override):
	stanzas = [ ]

	if control_override is not None:
		control_af = control_override
		testbed.blame('arg:'+control_override.spec)
	else:
		control_af = RelativeInputFile(act.what+'-testcontrol',
			tree, 'debian/tests/control')
	try:
		control = open(control_af.read(), 'r')
	except OSError, oe:
		if oe[0] != errno.ENOENT: raise
		return []

	lno = 0
	def badctrl(m): act.bomb('tests/control line %d: %s' % (lno, m))
	stz = None	# stz[field_name][index] = (lno, value)
			# special field names:
			# stz[' lno'] = number
			# stz[' tests'] = list of Test objects
	def end_stanza(stz):
		if stz is None: return
		stz[' errs'] = 0
		stanzas.append(stz)
		stz = None
		hcurrent = None

	initre = regexp.compile('([A-Z][-0-9a-z]*)\s*\:\s*(.*)$')
	while 1:
		l = control.readline()
		if not l: break
		lno += 1
		if not l.endswith('\n'): badctrl('unterminated line')
		if regexp.compile('\s*\#').match(l): continue
		if not regexp.compile('\S').match(l): end_stanza(stz); continue
		initmat = initre.match(l)
		if initmat:
			(fname, l) = initmat.groups()
			fname = string.capwords(fname)
			if stz is None:
				stz = { ' lno': lno, ' tests': [] }
			if not stz.has_key(fname): stz[fname] = [ ]
			hcurrent = stz[fname]
		elif regexp.compile('\s').match(l):
			if not hcurrent: badctrl('unexpected continuation')
		else:
			badctrl('syntax error')
		hcurrent.append((lno, l))
	end_stanza(stz)

	def testbadctrl(stz, lno, m):
		report_badctrl(lno, m)
		stz[' errs'] += 1

	for stz in stanzas:
		try:
			try: tnames = stz['Tests']
			except KeyError:
				tnames = ['*']
				raise Unsupported(stz[' lno'],
					'no Tests field')
			tnames = map((lambda lt: lt[1]), tnames)
			tnames = string.join(tnames).split()
			base = {
				'restrictions': [],
				'testsdir': 'debian/tests',
				'depends' : '@'
			}
			for fname in stz.keys():
				if fname.startswith(' '): continue
				vl = stz[fname]
				try: fclass = globals()['Field_'+
					fname.replace('-','_')]
				except KeyError: raise Unsupported(vl[0][0],
					'unknown metadata field %s' % fname)
				f = fclass(stz, fname, base, tnames, vl)
				f.parse()
			for tname in tnames:
				t = Test(tname, base, act)
				stz[' tests'].append(t)
		except Unsupported, u:
			for tname in tnames: u.report(tname)
			continue

	return stanzas

def print_exception(ei, msgprefix=''):
	if msgprefix: pstderr(msgprefix)
	(et, q, tb) = ei
	if et is Quit:
		pstderr('adt-run: ' + q.m)
		return q.ec
	else:
		pstderr("adt-run: unexpected, exceptional, error:")
		traceback.print_exc(None, sys.stderr)
		if trace_stream is not None:
			traceback.print_exc(None, trace_stream)
		return 20

def cleanup():
	global trace_stream
	try:
		rm_ec = 0
		if opts.tmpdir is None and tmpdir is not None:
			rmtree('tmpdir', tmpdir)
		if testbed is not None:
			testbed.reset_apt()
			testbed.stop()
		if rm_ec: bomb('rm -rf -- %s failed, code %d' % (tmpdir, ec))
		if trace_stream is not None:
			trace_stream.close()
			trace_stream = None
	except:
		print_exception(sys.exc_info(),
			'\nadt-run: error cleaning up:\n')
		os._exit(20)

#---------- registration, installation etc. of .deb's: Binaries

def determine_package(act):
	cmd = 'dpkg-deb --info --'.split(' ')+[act.af.read(),'control']
	(rc, output) = subprocess_cooked(cmd, stdout=subprocess.PIPE)
	if rc: badpkg('failed to parse binary package, code %d' % rc)
	re = regexp.compile('^\s*Package\s*:\s*([0-9a-z][-+.0-9a-z]*)\s*$')
	act.pkg = None
	for l in output.split('\n'):
		m = re.match(l)
		if not m: continue
		if act.pkg: badpkg('two Package: lines in control file')
		act.pkg = m.groups()[0]
	if not act.pkg: badpkg('no good Package: line in control file')

class Binaries:
 def __init__(b):
	b.dir = TemporaryDir('binaries')
	b.dir.write()
	ok = False

	if opts.gnupghome is None:
		opts.gnupghome = tmpdir+'/gnupg'

	b._debug('initialising')
	try:
		for x in ['pubring','secring']:
			os.stat(opts.gnupghome + '/' + x + '.gpg')
		ok = True
	except OSError, oe:
		if oe.errno != errno.ENOENT: raise

	if ok: b._debug('no key generation needed')
	else: b.genkey()

 def _debug(b, s):
	debug('* '+s)

 def genkey(b):
	b._debug('preparing for key generation')

	mkdir_okexist(os.path.dirname(opts.gnupghome), 02755)
	mkdir_okexist(opts.gnupghome, 0700)

	script = '''
  exec >&2
  cd "$1"
  cat <<"END" >key-gen-params
Key-Type: DSA
Key-Length: 1024
Key-Usage: sign
Name-Real: autopkgtest per-run key
Name-Comment: do not trust this key
Name-Email: autopkgtest@example.com
END
  set -x
  gpg --homedir="$1" --batch --gen-key key-gen-params
		'''
	cmdl = ['sh','-ec',script,'x',opts.gnupghome]
	rc = subprocess_cooked(cmdl, dbg=(genkey,script))[0]
	if rc:
		try:
			f = open(opts.gnupghome+'/key-gen-log')
			tp = file.read()
		except OSError, e: tp = e
		pstderr(tp)
		bomb('key generation failed, code %d' % rc)

 def apt_configs(b):
	return {
		"Dir::Etc::sourcelist": b.dir.read(True)+'sources.list',
	}

 def apt_pkg_gdebi_script(b, arg, middle):
	script = [
		'import apt_pkg',
		'import urllib',
		'arg = urllib.unquote("%s")' % urllib.quote(arg),
		]
	for (k,v) in b.apt_configs().iteritems():
		v = urllib.quote(v)
		script.append('apt_pkg.Config.Set("%s",urllib.unquote("%s"))'
				% (k, v))
	script += [
		'from GDebi.Cache import Cache',
		'cache = Cache()',
		]
	for m in middle:
		script += m + [
		'print res',
		'print d.missingDeps',
		'print d.requiredChanges',
		'assert(res)',
		'cache.commit()',
		''
		]
	return '\n'.join(script)
 def apt_get(b):
	ag = ['apt-get','-qy']
	for kv in b.apt_configs().iteritems():
		ag += ['-o', '%s=%s' % kv]
	return ag

 def reset(b):
	b._debug('reset')
	rmtree('binaries', b.dir.read())
	b.dir.invalidate()
	b.dir.write()
	b.install = []
	b.blamed = []
	b.registered = set()

 def register(b, act, pkg, af, forwhat, blamed):
	b._debug('register what=%s deb_%s=%s pkg=%s af=%s'
		% (act.what, forwhat, act.ah['deb_'+forwhat], pkg, str(af)))

	if act.ah['deb_'+forwhat] == 'ignore': return

	b.blamed += testbed.blamed

	leafname = pkg+'.deb'
	dest = RelativeOutputFile('binaries--'+leafname, b.dir, leafname)

	try: os.remove(dest.write())
	except OSError, oe:
		if oe.errno != errno.ENOENT: raise e

	try: os.link(af.read(), dest.write())
	except OSError, oe:
		if oe.errno != errno.EXDEV: raise e
		shutil.copy(af.read(), dest)

	if act.ah['deb_'+forwhat] == 'install':
		b.install.append(pkg)

	b.registered.add(pkg)

 def publish(b):
	b._debug('publish')

	script = '''
  exec >&2
  cd "$1"
  apt-ftparchive packages . >Packages
  gzip <Packages >Packages.gz
  apt-ftparchive release . >Release
  rm -f Release.gpg
  gpg --homedir="$2" --batch --detach-sign --armour -o Release.gpg Release
  gpg --homedir="$2" --batch --export >archive-key.pgp
		'''
	cmdl = ['sh','-ec',script,'x',b.dir.write(),opts.gnupghome]
	rc = subprocess_cooked(cmdl, dbg=('ftparchive',script))[0]
	if rc: bomb('apt-ftparchive or signature failed, code %d' % rc)

	b.dir.invalidate(True)
	apt_source = b.dir.read(True)

	so = TemporaryFile('vlds')
	script = '''
  exec 3>&1 >&2
  apt-key add archive-key.pgp
  echo "deb file://'''+apt_source+''' /" >sources.list
  cat /etc/apt/sources.list >>sources.list
  if [ "x`ls /var/lib/dpkg/updates`" != x ]; then
    echo >&2 "/var/lib/dpkg/updates contains some files, aargh"; exit 1
  fi
  '''+ ' '.join(b.apt_get()) +''' update >&2
  cat /var/lib/dpkg/status >&3
		'''
	testbed.mungeing_apt()
	rc = testbed.execute('apt-key', ['sh','-ec',script],
				so=so.write(True), cwd=b.dir.write(True),
				script=script)
	if rc: bomb('apt setup failed with exit code %d' % rc)

	testbed.blamed += b.blamed

	b._debug('publish reinstall checking...')
	pkgs_reinstall = set()
	pkg = None
	for l in open(so.read()):
		if l.startswith('Package: '):
			pkg = l[9:].rstrip()
		elif l.startswith('Status: install '):
			if pkg in b.registered:
				pkgs_reinstall.add(pkg)
				b._debug(' publish reinstall needs '+pkg)

	if pkgs_reinstall:
		for pkg in pkgs_reinstall: testbed.blame(pkg)
		what = 'apt-get-reinstall'
		cmdl = (b.apt_get() + ['--reinstall','install'] +
			[pkg for pkg in pkgs_reinstall])
		rc = testbed.execute(what, cmdl, script=None)
		if rc: badpkg("installation of basic binarries failed,"
				" exit code %d" % rc)

	b._debug('publish install...')
	for pkg in b.install:
		what = 'apt-get-install-%s' % pkg
		testbed.blame(pkg)
		cmdl = b.apt_get() + ['install',pkg]
		rc = testbed.execute(what, cmdl, script=None)
		if rc: badpkg("installation of %s failed, exit code %d"
				% (pkg, rc))

	b._debug('publish done')

#---------- processing of sources (building)

def source_rules_command(act,script,what,which,work,cwd,
				results_lines=0,xargs=[]):
	script = [	"exec 3>&1 >&2",
			"set -x"	] + script
	script = '\n'.join(script)
	so = TemporaryFile('%s-%s-results' % (what,which))
	rc = testbed.execute('%s-%s' % (what,which),
			['sh','-ec',script]+xargs, script=script,
			so=so.write(True), cwd=cwd)
	results = open(so.read()).read().rstrip('\n').split("\n")
	if rc: badpkg("%s failed with exit code %d" % (which,rc))
	if results_lines is not None and len(results) != results_lines:
		badpkg("got %d lines of results from %s where %d expected"
			% (len(results), which, results_lines))
	if results_lines==1: return results[0]
	return results

def build_source(act):
	act.blame = 'arg:'+act.af.spec
	testbed.blame(act.blame)
	testbed.needs_reset()

	what = act.what
	basename = act.af.spec

	if act.kind == 'dsc':
		dsc = act.af
		dsc_file = open(dsc.read())
		in_files = False
		fre = regexp.compile('^\s+[0-9a-f]+\s+\d+\s+([^/.][^/]*)$')
		for l in dsc_file:
			l = l.rstrip('\n')
			if l.startswith('Files:'): in_files = True; continue
			elif l.startswith('#'): pass
			elif not l.startswith(' '):
				in_files = False
				if l.startswith('Source:'):
					act.blame = 'dsc:'+l[7:].strip()
					testbed.blame(act.blame)
			if not in_files: continue

			m = fre.match(l)
			if not m: badpkg(".dsc contains unparseable line"
					" in Files: `%s'" % l)
			leaf = m.groups(0)[0]
			subfile = RelativeInputFile(what+'/'+leaf, dsc, leaf,
					sibling=True)
			subfile.read(True)
		dsc.read(True)

	if act.kind == 'ubtree':
		debiancontrol = RelativeInputFile(what+'-debiancontrol',
			act.af, 'debian/control')
		dsc = TemporaryFile(what+'-fakedsc')
		dsc_w = open(dsc.write(), 'w')
		for l in open(debiancontrol.read()):
			l = l.rstrip('\n')
			if not len(l): break
			print >>dsc_w, l
		print >>dsc_w, 'Binary: none-so-this-is-not-a-package-name'
		dsc_w.close()

	work = TemporaryDir(what+'-build')

	script = [
		'spec="$1"',
		'origpwd=`pwd`',
		'cd '+work.write(True)
	]

	if act.kind == 'ubtree':
		spec = '%s/real-tree' % work.write(True)
		create_command = '''
			rm -rf "$spec"
			mkdir "$spec"
			cp -rP --preserve=timestamps,links -- "$origpwd"/. "$spec"/.
			'''
		initcwd = act.af.read(True)

	if act.kind == 'dsc':
		spec = dsc.read(True)
		create_command = '''
			dpkg-source -x $spec
			'''
		initcwd = work.write(True)

	if opts.user: script += [
			'chown '+opts.user+' .',
			'spec="$spec" origpwd="$origpwd" '+opts.user_wrap(create_command)
			]
	else: script += [
			create_command
		]

	script += [
			'cd */.',
			'pwd >&3',
		]
	result_pwd = source_rules_command(act,script,what,'extract',work,
			cwd=initcwd, results_lines=1, xargs=['x',spec])

	script = binaries.apt_pkg_gdebi_script(
		dsc.read(True), [[
		'from GDebi.DscSrcPackage import DscSrcPackage',
		'd = DscSrcPackage(cache, arg)',
		'res = d.checkDeb()',
		 ],[
		'from GDebi.DebPackage import DebPackage',
		'd = DebPackage(cache)',
		'res = d.satisfyDependsStr("build-essential")',
		]])

	cmdl = ['python','-c',script]
	whatp = what+'-builddeps'
	rc = testbed.execute(what, cmdl, script=script)
	if rc: badpkg('build-depends install failed, exit code %d' % rc)

	script = [
			'cd "$1"',
			'dpkg-checkbuilddeps',
			opts.user_wrap('debian/rules build'),
		]
	source_rules_command(act,script,what,'build',work,
			cwd=initcwd, xargs=['x',result_pwd])

	if os.path.dirname(result_pwd)+'/' != work.read(True):
		badpkg("results dir `%s' is not in expected parent dir `%s'"
			% (result_pwd, work.read(True)))

	act.work = work
	act.tests_tree = InputDir(what+'-tests-tree',
				work.read(True)+os.path.basename(result_pwd),
				True)
	if act.ah['dsc_tests']:
		act.tests_tree.read()
		testbed.register_ephemeral(act.work)
		testbed.register_ephemeral(act.tests_tree)

	act.blamed = copy.copy(testbed.blamed)

	def debug_b(m): debug('* <%s:%s> %s' % (act.kind, act.what, m))
	act.binaries = []
	filter = act.ah['dsc_filter']
	debug_b('filter=%s' % filter)
	if filter != '_':
		script = [
			'cd '+work.write(True)+'/*/.',
			opts.user_wrap(opts.gainroot+' debian/rules binary'),
			'cd ..',
			'echo *.deb >&3',
			]
		result_debs = source_rules_command(act,script,what,
				'binary',work,work.write(True),results_lines=1)
		if result_debs == '*': debs = []
		else: debs = result_debs.split(' ')
		debug_b('debs='+`debs`)
		re = regexp.compile('^([-+.0-9a-z]+)_[^_/]+(?:_[^_/]+)\.deb$')
		for deb in debs:
			m = re.match(deb)
			if not m: badpkg("badly-named binary `%s'" % deb)
			pkg = m.groups()[0]
			debug_b(' deb=%s, pkg=%s' % (deb,pkg))
			for pat in filter.split(','):
				debug_b('  pat=%s' % pat)
				if not fnmatch.fnmatchcase(pkg,pat):
					debug_b('   no match')
					continue
				deb_what = pkg+'_'+what+'.deb'
				bin = RelativeInputFile(deb_what,work,deb,True)
				debug_b('  deb_what=%s, bin=%s' %
					(deb_what, str(bin)))
				binaries.register(act,pkg,bin,
					'forbuilds',testbed.blamed)
				act.binaries.append((pkg,bin))
				break
		debug_b('all done.')

#---------- main processing loop and main program

def process_actions():
	global binaries

	def debug_a1(m): debug('@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ '+m)
	def debug_a2(m): debug('@@@@@@@@@@@@@@@@@@@@ '+m)
	def debug_a3(m): debug('@@@@@@@@@@ '+m)

	debug_a1('starting')
	testbed.open()
	binaries = Binaries()

	for act in opts.actions:
		testbed.register_ephemeral(act.af)

	binaries.reset()

	debug_a1('builds ...')
	for act in opts.actions:
		debug_a2('%s %s' %
			(act.kind, act.what))

		testbed.prepare([])
		if act.kind == 'deb':
			testbed.blame('arg:'+act.af.spec)
			determine_package(act)
			testbed.blame('deb:'+act.pkg)
			binaries.register(act,act.pkg,act.af,
				'forbuilds',testbed.blamed)
		if act.kind == 'dsc' or act.kind == 'ubtree':
			build_source(act)
		if act.kind == 'tree':
			act.binaries = []

	debug_a1('builds done.')

	binaries.reset()
	control_override = None

	debug_a1('tests ...')
	for act in opts.actions:
		debug_a2('test %s %s' % (act.kind, act.what))

		testbed.needs_reset()
		if act.kind == 'control':
			control_override = act.af
		if act.kind == 'deb':
			binaries.register(act,act.pkg,act.af,'fortests',
				['deb:'+act.pkg])
		if act.kind == 'dsc' or act.kind == 'ubtree':
			for (pkg,bin) in act.binaries:
				binaries.register(act,pkg,bin,'fortests',
					act.blamed)
		if act.kind == 'dsc':
			if act.ah['dsc_tests']:
				debug_a3('read control ...')
				stanzas = read_control(act, act.tests_tree,
						control_override)
				testbed.blamed += act.blamed
				debug_a3('run_tests ...')
				run_tests(stanzas, act.tests_tree)
			control_override = None
		if act.kind == 'tree' or act.kind == 'ubtree':
			testbed.blame('arg:'+act.af.spec)
			stanzas = read_control(act, act.af, control_override)
			debug_a3('run_tests ...')
			run_tests(stanzas, act.af)
			control_override = None
	debug_a1('tests done.')

def main():
	global testbed
	global tmpdir
	try:
		parse_args()
	except SystemExit, se:
		os._exit(20)
	try:
		setup_trace()
		testbed = Testbed()
		testbed.start()
		finalise_options()
		process_actions()
	except:
		ec = print_exception(sys.exc_info(), '')
		cleanup()
		os._exit(ec)
	cleanup()
	os._exit(errorcode)

main()
